<html>
  <head>
    <base href="https://websim.ai/project-manhattan" />
    <title>
      Project Manhattan: Next-Generation MOS 6510-based CPU/GPU SoC Emulator
      Written in FreeBASIC
    </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Water.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Sky.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/foundation/6.6.3/css/foundation.min.css"></script>
    <!-- Adding Foundation CSS for styling the overlay -->
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
      #info {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        color: white;
        font-family: Arial, sans-serif;
        pointer-events: none;
        text-shadow: 1px 1px 2px black;
      }
      #metrics {
        position: absolute;
        top: 50px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
      }
      #benchmark {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
      }
      #source-code {
        position: absolute;
        top: 60px;
        right: 10px;
        width: 300px;
        height: 85%;
        color: lime;
        background-color: rgba(0, 0, 0, 0.7);
        overflow: auto;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
      }
      #emulator {
        position: absolute;
        top: 50%;
        left: 35%;
        transform: translate(-50%, -50%);
        width: 600px;
        height: 600px;
        color: white;
        background-color: rgba(0, 0, 0, 0.7);
        overflow-y: scroll;
        padding: 20px;
        border-radius: 10px;
        font-family: monospace;
        text-align: left;
      }
      .emulator-button {
        margin-top: 10px;
        text-align: center;
      }
      #terminal {
        font-family: "Courier New", Courier, monospace;
        color: lime;
        background-color: black;
        overflow: auto;
        height: 300px;
        width: 560px;
        padding: 10px;
        text-align: left;
        border-radius: 10px;
        filter: contrast(120%) brightness(80%);
        box-shadow: 0 0 8px #00ff00;
      }
      #command-input {
        display: block;
        margin: 0 auto;
        width: 90%;
        background-color: black;
        color: lime;
        border: 1px solid green;
        padding: 5px;
        font-family: "Courier New", Courier, monospace;
      }
      #graphics-viewport {
        width: 100%;
        height: 200px;
        background-color: black;
        margin-top: 10px;
        border: 1px solid #008080;
        overflow: hidden;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <div id="info">
      Project Manhattan: Next-Generation MOS 6510-based CPU/GPU SoC Emulator
      Written in FreeBASIC
    </div>
    <div id="metrics"></div>
    <div id="benchmark"></div>
    <div id="source-code">
      <pre>
' Project Manhattan: Next-Generation MOS 6510-based CPU/GPU SoC Emulator
' Version 2.0.1
' This code implements an advanced MOS 6510-based CPU/GPU System on Chip emulator
' with integrated 3D graphics capabilities for both retro and modern applications.

#include "mos6510.bi"
#include "gpu_core.bi"
#include "3d_engine.bi"
#include "memory_manager.bi"

CONST MAX_OBJECTS = 1000
CONST SCREEN_WIDTH = 1920
CONST SCREEN_HEIGHT = 1080

TYPE ObjectData
    model AS MODEL_3D PTR
    position AS VECTOR3D
    rotation AS VECTOR3D
    scale AS SINGLE
END TYPE

DIM SHARED g_objects(MAX_OBJECTS) AS ObjectData
DIM SHARED g_objectCount AS INTEGER
DIM SHARED g_fps AS INTEGER
DIM SHARED g_frameCounter AS INTEGER
DIM SHARED g_lastTime AS DOUBLE

DECLARE SUB InitializeSystem()
DECLARE SUB LoadResources()
DECLARE SUB MainLoop()
DECLARE SUB RenderFrame()
DECLARE SUB UpdatePhysics()
DECLARE FUNCTION Benchmark() AS INTEGER

SUB InitializeSystem()
    CPU_Init()
    GPU_Init(SCREEN_WIDTH, SCREEN_HEIGHT, 32)
    Memory_Init(64 * 1024 * 1024)  ' 64MB of unified memory
    _3D_InitEngine()
END SUB

SUB LoadResources()
    DIM AS INTEGER i
    FOR i = 0 TO MAX_OBJECTS - 1
        g_objects(i).model = _3D_LoadModel("assets/torus_knot.obj")
        g_objects(i).position = Vector3D(RND * 200 - 100, RND * 200 - 100, RND * 200 - 100)
        g_objects(i).rotation = Vector3D(0, 0, 0)
        g_objects(i).scale = RND * 0.5 + 0.5
    NEXT i
    g_objectCount = MAX_OBJECTS
END SUB

SUB MainLoop()
    DIM AS DOUBLE currentTime
    DO
        currentTime = TIMER
        IF currentTime - g_lastTime &gt;= 1 THEN
            g_fps = g_frameCounter
            g_frameCounter = 0
            g_lastTime = currentTime
        END IF

        UpdatePhysics()
        RenderFrame()
        
        g_frameCounter += 1
        CPU_ExecuteNextInstruction()
        GPU_SwapBuffers()
    LOOP WHILE NOT CPU_IsHalted()
END SUB

SUB UpdatePhysics()
    DIM AS INTEGER i
    FOR i = 0 TO g_objectCount - 1
        g_objects(i).rotation.x += 0.01 * (i MOD 2)
        g_objects(i).rotation.y += 0.01 * ((i + 1) MOD 2)
        g_objects(i).rotation.z += 0.01 * ((i + 2) MOD 2)
    NEXT i
END SUB

SUB RenderFrame()
    GPU_ClearScreen(&amp;HFF000000)  ' Clear to black
    
    _3D_SetCamera(Vector3D(0, 0, -200), Vector3D(0, 0, 0))
    
    DIM AS INTEGER i
    FOR i = 0 TO g_objectCount - 1
        _3D_RenderModel(g_objects(i).model, g_objects(i).position, _
                        g_objects(i).rotation, g_objects(i).scale)
    NEXT i
    
    GPU_DrawText("FPS: " &amp; g_fps, 10, 10, &amp;HFFFFFFFF)
    GPU_DrawText("Objects: " &amp; g_objectCount, 10, 30, &amp;HFFFFFFFF)
    GPU_DrawText("CPU Clock: " &amp; CPU_GetClockSpeed() &amp; " MHz", 10, 50, &amp;HFFFFFFFF)
END SUB

FUNCTION Benchmark() AS INTEGER
    DIM AS DOUBLE startTime = TIMER
    DIM AS INTEGER frames = 0
    DIM AS DOUBLE elapsedTime
    
    DO
        UpdatePhysics()
        RenderFrame()
        GPU_SwapBuffers()
        frames += 1
        elapsedTime = TIMER - startTime
    LOOP WHILE elapsedTime &lt; 10  ' Run for 10 seconds
    
    RETURN (frames / elapsedTime) * g_objectCount / 100
END FUNCTION

' Main program
InitializeSystem()
LoadResources()
MainLoop()

DIM AS INTEGER score = Benchmark()
PRINT "Benchmark Score: "; score

CPU_Shutdown()
GPU_Shutdown()
Memory_Shutdown()
END
</pre
      >
    </div>
    <div
      id="emulator"
      style="
        left: calc(50% - 120px);
        top: 50%;
        transform: translate(-50%, -50%);
      "
    >
      <h4>UNIX Posix Terminal</h4>
      <pre id="terminal">
user@project-manhattan:~$ debug_info

=== 3D Benchmark Debug Data ===
Objects rendered: 500
Resolution: 1920x1080
Shader complexity: High
Post-processing: Enabled (Bloom, SSAO)
Current FPS: 78
GPU utilization: 92%
VRAM usage: 2.7 GB

=== MOS 6510-based CPU/GPU SoC Emulator Debug Info ===
CPU clock: 1.023 MHz
GPU clock: 40 MHz
Memory: 64 MB unified
Current instruction: LDA #$FF
Registers:
  A: $7F  X: $00  Y: $C4
  PC: $F000  SP: $01FF
Flags: NV-BDIZC
       10110000
Graphics mode: AGA HAM8 (4096 colors)
Sprite data:
  Sprite 0: Enabled, (x:120, y:80)
  Sprite 1: Disabled
Copper list: Active, 64 instructions

user@project-manhattan:~$</pre
      >
      <div class="emulator-button">
        <button class="button" onclick="startTerminal()">Start Terminal</button>
        <button class="button" onclick="runCommand()">Run Command</button>
      </div>
      <textarea id="command-input" rows="5" cols="35"></textarea>
      <div id="graphics-viewport"></div>

      <!-- Updated graphics viewports -->
      <div
        style="
          display: flex;
          justify-content: space-between;
          flex-wrap: wrap;
          margin-top: 20px;
        "
      >
        <div
          class="mini-viewport"
          style="
            width: 135px;
            height: 135px;
            background-color: #000;
            border: 1px solid #008080;
            border-radius: 5px;
            margin-bottom: 10px;
          "
        >
          <canvas id="vic-ii-demo" width="135" height="135">
            <script>
              // VIC-II demo
              const vicIICanvas = document.getElementById("vic-ii-demo");
              const vicIICtx = vicIICanvas.getContext("2d");

              // Define some VIC-II colors
              const vicIIColors = [
                "#000000",
                "#FFFFFF",
                "#880000",
                "#AAFFEE",
                "#CC44CC",
                "#00CC55",
                "#0000AA",
                "#EEEE77",
                "#DD8855",
                "#664400",
                "#FF7777",
                "#333333",
                "#777777",
                "#AAFF66",
                "#0088FF",
                "#BBBBBB",
              ];

              function drawVICIIDemo() {
                // Clear the canvas
                vicIICtx.fillStyle = vicIIColors[0];
                vicIICtx.fillRect(0, 0, 135, 135);

                // Draw a simple sprite
                vicIICtx.fillStyle = vicIIColors[7];
                vicIICtx.fillRect(60, 60, 15, 15);

                // Draw some colorful pixels
                for (let i = 0; i < 16; i++) {
                  vicIICtx.fillStyle = vicIIColors[i];
                  vicIICtx.fillRect(i * 8, 0, 8, 8);
                }

                // Simulate character mode
                vicIICtx.font = "8px monospace";
                vicIICtx.fillStyle = vicIIColors[1];
                vicIICtx.fillText("HELLO VIC-II", 10, 30);

                // Simulate high-resolution mode
                for (let y = 40; y < 60; y++) {
                  for (let x = 0; x < 135; x++) {
                    if ((x + y) % 2 === 0) {
                      vicIICtx.fillStyle = vicIIColors[2];
                      vicIICtx.fillRect(x, y, 1, 1);
                    }
                  }
                }

                // Simulate multicolor mode
                for (let y = 80; y < 135; y += 2) {
                  for (let x = 0; x < 135; x += 2) {
                    let colorIndex = Math.floor(
                      Math.random() * vicIIColors.length,
                    );
                    vicIICtx.fillStyle = vicIIColors[colorIndex];
                    vicIICtx.fillRect(x, y, 2, 2);
                  }
                }
              }

              // Initial draw
              drawVICIIDemo();

              // Update demo periodically
              setInterval(drawVICIIDemo, 1000);
            </script>
          </canvas>
        </div>
        <div
          class="mini-viewport"
          style="
            width: 135px;
            height: 135px;
            background-color: #000;
            border: 1px solid #008080;
            border-radius: 5px;
            margin-bottom: 10px;
          "
        >
          <canvas id="svga-demo" width="135" height="135">
            <script>
              // SVGA demo
              const svgaCanvas = document.getElementById("svga-demo");
              const svgaCtx = svgaCanvas.getContext("2d");

              function drawSVGADemo() {
                // Clear the canvas
                svgaCtx.fillStyle = "#000000";
                svgaCtx.fillRect(0, 0, 135, 135);

                // Draw a gradient background
                const gradient = svgaCtx.createLinearGradient(0, 0, 135, 135);
                gradient.addColorStop(0, "#000080");
                gradient.addColorStop(1, "#4B0082");
                svgaCtx.fillStyle = gradient;
                svgaCtx.fillRect(0, 0, 135, 135);

                // Draw some shapes
                svgaCtx.beginPath();
                svgaCtx.arc(67, 67, 50, 0, 2 * Math.PI);
                svgaCtx.fillStyle = "rgba(255, 255, 0, 0.5)";
                svgaCtx.fill();

                svgaCtx.beginPath();
                svgaCtx.moveTo(20, 20);
                svgaCtx.lineTo(115, 20);
                svgaCtx.lineTo(67, 115);
                svgaCtx.closePath();
                svgaCtx.fillStyle = "rgba(0, 255, 0, 0.5)";
                svgaCtx.fill();

                // Draw some text
                svgaCtx.font = "12px Arial";
                svgaCtx.fillStyle = "#FFFFFF";
                svgaCtx.textAlign = "center";
                svgaCtx.fillText("SVGA 800x600", 67, 15);

                // Draw some lines
                svgaCtx.strokeStyle = "#FF00FF";
                svgaCtx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                  svgaCtx.beginPath();
                  svgaCtx.moveTo(0, i * 27);
                  svgaCtx.lineTo(135, 135 - i * 27);
                  svgaCtx.stroke();
                }
              }

              // Initial draw
              drawSVGADemo();

              // Update demo periodically
              setInterval(drawSVGADemo, 1000);
            </script>
          </canvas>
        </div>
        <div
          class="mini-viewport"
          style="
            width: 135px;
            height: 135px;
            background-color: #000;
            border: 1px solid #008080;
            border-radius: 5px;
            margin-bottom: 10px;
          "
        >
          <canvas id="copperlists-demo" width="135" height="135">
            <script>
              // Copperlists demo with ECS and 32-bit ARGB colors
              const copperlistsCanvas =
                document.getElementById("copperlists-demo");
              const copperlistsCtx = copperlistsCanvas.getContext("2d");

              class CopperBar {
                constructor(y, color, speed) {
                  this.y = y;
                  this.color = color;
                  this.speed = speed;
                }

                update() {
                  this.y += this.speed;
                  if (this.y > 135) this.y = 0;
                  if (this.y < 0) this.y = 135;
                }

                draw(ctx) {
                  ctx.fillStyle = this.color;
                  ctx.fillRect(0, Math.floor(this.y), 135, 1);
                }
              }

              const copperBars = [];
              for (let i = 0; i < 20; i++) {
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
                const a = Math.random() * 0.5 + 0.5; // Semi-transparent
                copperBars.push(
                  new CopperBar(
                    i * 7,
                    `rgba(${r},${g},${b},${a})`,
                    (Math.random() - 0.5) * 2,
                  ),
                );
              }

              function drawCopperlistsDemo() {
                // Clear the canvas
                copperlistsCtx.fillStyle = "#000000";
                copperlistsCtx.fillRect(0, 0, 135, 135);

                // Update and draw copper bars
                copperBars.forEach((bar) => {
                  bar.update();
                  bar.draw(copperlistsCtx);
                });

                // Draw some text
                copperlistsCtx.font = "10px Arial";
                copperlistsCtx.fillStyle = "#FFFFFF";
                copperlistsCtx.textAlign = "center";
                copperlistsCtx.fillText("32-bit ARGB", 67, 15);
                copperlistsCtx.fillText("Copperlists", 67, 30);

                // Draw a simple sprite that moves through the copper bars
                const spriteSize = 10;
                const spriteX = (Date.now() / 20) % (135 - spriteSize);
                copperlistsCtx.fillStyle = "#FFFFFF";
                copperlistsCtx.fillRect(spriteX, 60, spriteSize, spriteSize);
              }

              // Initial draw
              drawCopperlistsDemo();

              // Update demo
              setInterval(drawCopperlistsDemo, 1000 / 60); // 60 FPS
            </script>
          </canvas>
        </div>
        <div
          class="mini-viewport"
          style="
            width: 135px;
            height: 135px;
            background-color: #000;
            border: 1px solid #008080;
            border-radius: 5px;
            margin-bottom: 10px;
          "
        >
          <canvas id="aga-ham8-demo" width="135" height="135">
            <script>
              // AGA HAM8 demo
              const agaHam8Canvas = document.getElementById("aga-ham8-demo");
              const agaHam8Ctx = agaHam8Canvas.getContext("2d");

              function drawAGAHAM8Demo() {
                // Clear the canvas
                agaHam8Ctx.fillStyle = "#000000";
                agaHam8Ctx.fillRect(0, 0, 135, 135);

                // Generate all 4096 colors
                const colors = [];
                for (let r = 0; r < 16; r++) {
                  for (let g = 0; g < 16; g++) {
                    for (let b = 0; b < 16; b++) {
                      colors.push(`rgb(${r * 17},${g * 17},${b * 17})`);
                    }
                  }
                }

                // Draw color swatches
                const swatchSize = Math.ceil(Math.sqrt((135 * 135) / 4096));
                let x = 0;
                let y = 0;

                for (let i = 0; i < 4096; i++) {
                  agaHam8Ctx.fillStyle = colors[i];
                  agaHam8Ctx.fillRect(x, y, swatchSize, swatchSize);

                  x += swatchSize;
                  if (x + swatchSize > 135) {
                    x = 0;
                    y += swatchSize;
                  }
                }

                // Draw text
                agaHam8Ctx.font = "10px Arial";
                agaHam8Ctx.fillStyle = "#FFFFFF";
                agaHam8Ctx.textAlign = "center";
                agaHam8Ctx.fillText("AGA HAM8", 67, 15);
                agaHam8Ctx.fillText("4096 Colors", 67, 30);

                // Add a moving highlight to showcase color depth
                const time = Date.now() / 1000;
                const highlightX = Math.cos(time) * 45 + 67;
                const highlightY = Math.sin(time) * 45 + 67;
                const gradient = agaHam8Ctx.createRadialGradient(
                  highlightX,
                  highlightY,
                  0,
                  highlightX,
                  highlightY,
                  20,
                );
                gradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
                gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                agaHam8Ctx.fillStyle = gradient;
                agaHam8Ctx.fillRect(0, 0, 135, 135);
              }

              // Initial draw
              drawAGAHAM8Demo();

              // Update demo
              setInterval(drawAGAHAM8Demo, 1000 / 30); // 30 FPS
            </script>
          </canvas>
        </div>
      </div>

      <script>
        function updateDebugInfo() {
          const terminal = document.getElementById("terminal");
          const now = new Date();
          const fps = Math.floor(Math.random() * 20) + 70; // Random FPS between 70 and 90
          const gpuUtilization = Math.floor(Math.random() * 10) + 85; // Random GPU utilization between 85% and 95%
          const vramUsage = (Math.random() * 0.5 + 2.5).toFixed(1); // Random VRAM usage between 2.5 and 3.0 GB
          const cpuClock = (Math.random() * 0.1 + 1.0).toFixed(3); // Random CPU clock between 1.000 and 1.100 MHz
          const gpuClock = Math.floor(Math.random() * 5) + 38; // Random GPU clock between 38 and 42 MHz

          const registers = {
            A: Math.floor(Math.random() * 256)
              .toString(16)
              .padStart(2, "0")
              .toUpperCase(),
            X: Math.floor(Math.random() * 256)
              .toString(16)
              .padStart(2, "0")
              .toUpperCase(),
            Y: Math.floor(Math.random() * 256)
              .toString(16)
              .padStart(2, "0")
              .toUpperCase(),
            PC: (Math.floor(Math.random() * 256) + 0xf000)
              .toString(16)
              .toUpperCase(),
            SP: (Math.floor(Math.random() * 256) + 0x0100)
              .toString(16)
              .toUpperCase(),
          };

          const flags = Math.floor(Math.random() * 256)
            .toString(2)
            .padStart(8, "0");

          const spriteX = Math.floor(Math.random() * 320);
          const spriteY = Math.floor(Math.random() * 200);

          const copperInstructions = Math.floor(Math.random() * 32) + 48; // Random number of copper instructions between 48 and 80

          const updatedInfo = `user@project-manhattan:~$ debug_info

=== 3D Benchmark Debug Data ===
Objects rendered: 500
Resolution: 1920x1080
Shader complexity: High
Post-processing: Enabled (Bloom, SSAO)
Current FPS: ${fps}
GPU utilization: ${gpuUtilization}%
VRAM usage: ${vramUsage} GB

=== MOS 6510-based CPU/GPU SoC Emulator Debug Info ===
CPU clock: ${cpuClock} MHz
GPU clock: ${gpuClock} MHz
Memory: 64 MB unified
Current instruction: LDA #$FF
Registers:
  A: $${registers.A}  X: $${registers.X}  Y: $${registers.Y}
  PC: $${registers.PC}  SP: $${registers.SP}
Flags: NV-BDIZC
       ${flags}
Graphics mode: AGA HAM8 (4096 colors)
Sprite data:
  Sprite 0: Enabled, (x:${spriteX}, y:${spriteY})
  Sprite 1: Disabled
Copper list: Active, ${copperInstructions} instructions

user@project-manhattan:~$`;

          terminal.innerHTML = updatedInfo;
        }

        // Update debug info every 2 seconds
        setInterval(updateDebugInfo, 2000);

        // Initial update
        updateDebugInfo();
      </script>
    </div>

    <script>
      // Set up the scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        2000,
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.5;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Add orbit controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.maxPolarAngle = Math.PI * 0.495;
      controls.target.set(0, 10, 0);
      controls.minDistance = 40.0;
      controls.maxDistance = 500.0;

      // Create the water
      const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
      const water = new THREE.Water(waterGeometry, {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: new THREE.TextureLoader().load(
          "https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/waternormals.jpg",
          function (texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          },
        ),
        sunDirection: new THREE.Vector3(),
        sunColor: 0xffffff,
        waterColor: 0x001e0f,
        distortionScale: 3.7,
        fog: scene.fog !== undefined,
      });
      water.rotation.x = -Math.PI / 2;
      water.receiveShadow = true;
      scene.add(water);

      // Create the sky
      const sky = new THREE.Sky();
      sky.scale.setScalar(10000);
      scene.add(sky);

      const skyUniforms = sky.material.uniforms;
      skyUniforms["turbidity"].value = 10;
      skyUniforms["rayleigh"].value = 2;
      skyUniforms["mieCoefficient"].value = 0.005;
      skyUniforms["mieDirectionalG"].value = 0.8;

      const parameters = {
        elevation: 2,
        azimuth: 180,
      };

      const pmremGenerator = new THREE.PMREMGenerator(renderer);

      function updateSun() {
        const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
        const theta = THREE.MathUtils.degToRad(parameters.azimuth);
        const sun = new THREE.Vector3();
        sun.setFromSphericalCoords(1, phi, theta);
        sky.material.uniforms["sunPosition"].value.copy(sun);
        water.material.uniforms["sunDirection"].value.copy(sun).normalize();
        scene.environment = pmremGenerator.fromScene(sky).texture;
      }

      updateSun();

      // Create complex geometry for benchmark
      const complexGeometry = new THREE.TorusKnotGeometry(10, 3, 100, 16);
      const complexMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.9,
        roughness: 0.1,
        envMap: scene.environment,
        envMapIntensity: 1.0,
      });

      const NUM_OBJECTS = 500;
      const objects = [];

      for (let i = 0; i < NUM_OBJECTS; i++) {
        const object = new THREE.Mesh(complexGeometry, complexMaterial);
        object.position.set(
          Math.random() * 200 - 100,
          Math.random() * 200 - 100,
          Math.random() * 200 - 100,
        );
        object.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI,
        );
        object.scale.setScalar(Math.random() * 0.5 + 0.5);
        object.castShadow = true;
        object.receiveShadow = true;
        scene.add(object);
        objects.push(object);
      }

      // Add directional light (sun)
      const sunLight = new THREE.DirectionalLight(0xffffaa, 1.5);
      sunLight.position.set(50, 100, 50);
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      sunLight.shadow.camera.near = 1;
      sunLight.shadow.camera.far = 500;
      scene.add(sunLight);

      // Set up camera position
      camera.position.set(30, 30, 100);

      // Post-processing
      const composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5,
        0.4,
        0.85,
      );
      bloomPass.threshold = 0.5;
      bloomPass.strength = 0.8;
      bloomPass.radius = 0.3;
      composer.addPass(bloomPass);

      // Metrics display
      const metricsElement = document.getElementById("metrics");
      const benchmarkElement = document.getElementById("benchmark");

      let frameCount = 0;
      let lastTime = performance.now();
      let fps = 0;

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        frameCount++;

        if (time >= lastTime + 1000) {
          fps = Math.round((frameCount * 1000) / (time - lastTime));
          frameCount = 0;
          lastTime = time;
        }

        // Rotate objects
        objects.forEach((object, index) => {
          object.rotation.x += 0.01 * (index % 2 ? 1 : -1);
          object.rotation.y += 0.01 * (index % 3 ? 1 : -1);
        });

        // Update water
        water.material.uniforms["time"].value += 1.0 / 60.0;

        controls.update();
        composer.render();

        // Update metrics display
        metricsElement.innerHTML = `
    FPS: ${fps}<br>
    Objects: ${NUM_OBJECTS}<br>
    Resolution: ${window.innerWidth}x${window.innerHeight}
  `;
      }

      animate();

      // Benchmark
      let benchmarkDuration = 10000; // 10 seconds
      let benchmarkStartTime = performance.now();
      let totalFrames = 0;

      function runBenchmark() {
        if (performance.now() - benchmarkStartTime < benchmarkDuration) {
          totalFrames++;
          requestAnimationFrame(runBenchmark);
        } else {
          const averageFPS = Math.round(
            totalFrames / (benchmarkDuration / 1000),
          );
          const score = Math.round((averageFPS * NUM_OBJECTS) / 100);
          benchmarkElement.innerHTML = `
      Benchmark Results:<br>
      Average FPS: ${averageFPS}<br>
      Score: ${score}
    `;
        }
      }

      runBenchmark();

      // Handle window resizing
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      // Start terminal
      function startTerminal() {
        const terminalOutput = document.getElementById("terminal");
        terminalOutput.innerHTML = `user@project-manhattan:~$`;

        // Additional terminal logic can be added here
        // For example, initializing terminal state, etc.
      }

      // Run command
      function runCommand() {
        const commandInput = document.getElementById("command-input").value;
        const terminalOutput = document.getElementById("terminal");
        terminalOutput.innerHTML +=
          "\nuser@project-manhattan:~$ " + commandInput;

        // Interpret and execute the command
        interpretCommand(commandInput);
      }

      // Bash compatible command interpreter with ANSI C and FreeBASIC support (emulated)
      function interpretCommand(command) {
        const terminalOutput = document.getElementById("terminal");
        const [cmd, ...args] = command.trim().split(/\s+/);

        switch (cmd) {
          case "clear":
            terminalOutput.innerHTML = `user@project-manhattan:~$`;
            break;
          case "echo":
            terminalOutput.innerHTML += "\n" + args.join(" ");
            break;
          case "start_emulator":
            terminalOutput.innerHTML += "\nStarting 6510 Emulator...";
            startEmulator();
            break;
          case "run_benchmark":
            terminalOutput.innerHTML += "\nRunning 3D Benchmark...";
            runBenchmark();
            break;
          case "help":
            terminalOutput.innerHTML += `
\nAvailable Commands:
clear           - Clear the terminal screen.
echo [message]  - Print a message to the terminal.
start_emulator  - Start the MOS 6510 emulator.
run_benchmark   - Run the 3D graphics benchmark.
help            - Display this help message.
c [source.c]    - Compile and execute ANSI C source code.
fb [source.bas] - Compile and execute FreeBASIC source code.
            `;
            break;
          case "c":
            if (args.length > 0) {
              const sourceCode = args.join(" ");
              compileAndRunC(sourceCode);
            } else {
              terminalOutput.innerHTML += `\nc: missing argument 'source.c'`;
            }
            break;
          case "fb":
            if (args.length > 0) {
              const sourceCode = args.join(" ");
              compileAndRunFreeBASIC(sourceCode);
            } else {
              terminalOutput.innerHTML += `\nfb: missing argument 'source.bas'`;
            }
            break;
          // Add more commands as needed for the 6502 emulator, the 3D benchmark, ANSI C, and FreeBASIC processing as per your requirements.

          default:
            terminalOutput.innerHTML += `\nbash: ${cmd}: command not found`;
        }
      }

      // ANSI C compilation and execution (emulated)
      function compileAndRunC(sourceCode) {
        // Placeholder: Here you would invoke an actual ANSI C compiler and execute the compiled code.
        // For the purpose of this simulation, we'll display a mock compilation and execution process.
        const terminalOutput = document.getElementById("terminal");
        terminalOutput.innerHTML += `\nCompiling and running ${sourceCode}...\n`;
        terminalOutput.innerHTML += `\n[gcc] Compilation successful.\n`;
        terminalOutput.innerHTML += `\n[output] Hello, ANSI C World!\n`;
      }

      // FreeBASIC compilation and execution (emulated)
      function compileAndRunFreeBASIC(sourceCode) {
        // Placeholder: Here you would invoke an actual FreeBASIC compiler and execute the compiled code.
        // For the purpose of this simulation, we'll display a mock compilation and execution process.
        const terminalOutput = document.getElementById("terminal");
        terminalOutput.innerHTML += `\nCompiling and running ${sourceCode}...\n`;
        terminalOutput.innerHTML += `\n[fbc] Compilation successful.\n`;
        terminalOutput.innerHTML += `\n[output] Hello, FreeBASIC World!\n`;
      }

      // Graphics Viewport
      const graphicsViewport = document.getElementById("graphics-viewport");
      const graphicsViewportRenderer = new THREE.WebGLRenderer({
        antialias: true,
      });
      graphicsViewportRenderer.setPixelRatio(window.devicePixelRatio);
      graphicsViewportRenderer.setSize(
        graphicsViewport.clientWidth,
        graphicsViewport.clientHeight,
      );
      graphicsViewport.appendChild(graphicsViewportRenderer.domElement);

      const graphicsViewportScene = new THREE.Scene();
      const graphicsViewportCamera = new THREE.PerspectiveCamera(
        30,
        graphicsViewport.clientWidth / graphicsViewport.clientHeight,
        0.1,
        1000,
      );
      graphicsViewportCamera.position.z = 5;

      const graphicsViewportGeometry = new THREE.BoxGeometry();
      const graphicsViewportMaterial = new THREE.MeshLambertMaterial({
        color: 0x00ff00,
      });
      const graphicsViewportCube = new THREE.Mesh(
        graphicsViewportGeometry,
        graphicsViewportMaterial,
      );
      graphicsViewportScene.add(graphicsViewportCube);

      const ambientLight = new THREE.AmbientLight(0x404040);
      graphicsViewportScene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1, 100);
      pointLight.position.set(10, 10, 10);
      graphicsViewportScene.add(pointLight);

      const demos = [
        function displayVICIIDemo() {
          // Set up and display VIC-II demo
          graphicsViewportCube.material.color.set(0x00ff00); // Green
          graphicsViewportCube.rotation.x = 0;
          graphicsViewportCube.rotation.y = 0;
          graphicsViewportCube.scale.set(1, 1, 1);
        },
        function displaySVGADemo() {
          // Set up and display SVGA demo
          graphicsViewportCube.material.color.set(0x0000ff); // Blue
          graphicsViewportCube.rotation.x = Math.PI / 4;
          graphicsViewportCube.rotation.y = Math.PI / 4;
          graphicsViewportCube.scale.set(1.5, 1.5, 1.5);
        },
        function displayCopperlistsDemo() {
          // Set up and display Copperlists demo
          graphicsViewportCube.material.color.set(0xff0000); // Red
          graphicsViewportCube.rotation.x = Math.PI / 2;
          graphicsViewportCube.rotation.y = Math.PI / 2;
          graphicsViewportCube.scale.set(1, 1, 1);

          // Copper list effect using 32-bit ARGB colors
          let gradient = new THREE.Texture(createCopperlistGradient());
          gradient.needsUpdate = true;
          graphicsViewportCube.material.map = gradient;
        },
        function displayAGAHAM8Demo() {
          // Set up and display AGA HAM8 demo
          graphicsViewportCube.material.color.set(0xffff00); // Yellow
          graphicsViewportCube.rotation.x = Math.PI / 8;
          graphicsViewportCube.rotation.y = Math.PI / 8;
          graphicsViewportCube.scale.set(0.5, 0.5, 0.5);
        },
        function displayHDRDemo() {
          // Set up and display HDR demo
          graphicsViewportCube.material.color.set(0x00ff00); // Green
          graphicsViewportCube.rotation.x = Math.PI;
          graphicsViewportCube.rotation.y = Math.PI;
          graphicsViewportCube.scale.set(2, 2, 2);
        },
      ];
      let currentDemo = 0;

      function animateGraphicsViewport() {
        requestAnimationFrame(animateGraphicsViewport);

        // Run the current demo
        demos[currentDemo % demos.length]();

        graphicsViewportCube.rotation.x += 0.01;
        graphicsViewportCube.rotation.y += 0.01;

        graphicsViewportRenderer.render(
          graphicsViewportScene,
          graphicsViewportCamera,
        );

        // Loop through the demos
        if (
          Math.floor(performance.now() / 5000) % demos.length !==
          currentDemo
        ) {
          currentDemo = Math.floor(performance.now() / 5000) % demos.length;
        }
      }

      animateGraphicsViewport();

      // Create Copperlist gradient
      function createCopperlistGradient() {
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 1;

        const context = canvas.getContext("2d");
        const gradient = context.createLinearGradient(0, 0, 256, 0);
        gradient.addColorStop(0, "rgba(255,0,0,1)"); // Red
        gradient.addColorStop(0.5, "rgba(0,255,0,1)"); // Green
        gradient.addColorStop(1, "rgba(0,0,255,1)"); // Blue

        context.fillStyle = gradient;
        context.fillRect(0, 0, 256, 1);

        return canvas;
      }

      window.addEventListener("resize", () => {
        graphicsViewportRenderer.setSize(
          graphicsViewport.clientWidth,
          graphicsViewport.clientHeight,
        );
        graphicsViewportCamera.aspect =
          graphicsViewport.clientWidth / graphicsViewport.clientHeight;
        graphicsViewportCamera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
