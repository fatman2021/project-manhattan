print #1, "// The MIT License"
print #1, "// Character ROM           Copyright © 1959-2011 National Semiconductor Corporation"
print #1, "//                         Copyright © 2011-present Texas Instruments Incorporated"
print #1, "// Dartmouth BASIC         Copyright © 1964-1979 John G. Kemény, Thomas E. Kurtz"
print #1, "// Microsoft BASIC         Copyright © 1975-present Microsoft Corporation"
print #1, "// Commodore KERNAL ROM    Copyright © 1977-1994 Commodore International Limited"
print #1, "//                         Copyright © 1995-1996 Escom"
print #1, "//                         Copyright © 1997-2008 Tulip Computers NV"
print #1, "//                         Copyright © 2008-2009 Nedfield NV"
print #1, "// MOS Technology 6510     Copyright © 1982-2001 MOS Technology, Inc."
print #1, "// OpenGL Shading Language Copyright © 2004-2006 OpenGLARB"
print #1, "//    		    	      Copyright © 2006-present The Khronos Group, Inc."
print #1, "// FreeBASIC               Copyright © 2004-present The FreeBASIC Development Team"
print #1, "// Shadertoy               Copyright © 2013-present Inigo Quilez & Pol Jeremias"
print #1, "// Project Manhattan       Copyright © 2019-present Project Manhattan Team"
print #1, "// Permission is hereby granted, free of charge, to any person "
print #1, "// obtaining a copy of this software and associated documentation "
print #1, "// files (the 'Software'), to deal in the Software without restriction,"
print #1, "// including without limitation the rights to use, copy, modify, merge, "
print #1, "// publish, distribute, sublicense, and/or sell copies of the Software, "
print #1, "// and to permit persons to whom the Software is furnished to do so, "
print #1, "// subject to the following conditions: The above copyright notice and"
print #1, "// this permission notice shall be included in all copies or"
print #1, "// substantial portions of the Software."
print #1, ""
print #1, "// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,"
print #1, "// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES"
print #1, "// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND"
print #1, "// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT"
print #1, "// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,"
print #1, "// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
print #1, "// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER"
print #1, "// DEALINGS IN THE SOFTWARE."
print #1, "#if HW_PERFORMANCE==0"
print #1, "#define AA 1"
print #1, "#else"
print #1, "#define AA 2             "
print #1, "#endif"
print #1, ""
print #1, "#define ZERO (min(iFrame,0))"
print #1, ""
print #1, "#define SAMPLES 32"
print #1, "#define MAXDEPTH 10"
print #1, ""
print #1, "#if 1 "
print #1, "#define INVERSEAO 1      "
print #1, "#define MINWEIGHTMODE 0  "
print #1, "#define WEIGHTMODE 1    "
print #1, "#else"
print #1, "#define INVERSEAO 0"
print #1, "#define MINWEIGHTMODE 1"
print #1, "#define WEIGHTMODE 0"
print #1, "#endif"
print #1, ""
print #1, "#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062"
print #1, ""
print #1, "#define OBJECT_MAP_FUNCTION map1"
print #1, "#define RECURSION"
print #1, "#define RAY_COUNT 15 "
print #1, ""
print #1, "#define calcRecursion rec4 "
print #1, "#define DIST_EPSILON 0.005"
print #1, ""
print #1, "#define ID_SKY 3.0"
print #1, "#define ID_FLOOR 1.0"
print #1, "#define ID_LIGHT 1.001"
print #1, "#define ID_GLASS_WALL 2.000"
print #1, "#define ETA 0.75"
print #1, "#define M_PI PI"
print #1, ""
print #1, "#define DENSITY_MIN 0.1"
print #1, "#define DENSITY_MAX 1.0"
print #1, "#define MATERIAL_COLOR vec3(0.5,0.8,1)*0.1"
print #1, "#define AIR_COLOR vec3(0.5,0.8,1)*0.1"
print #1, ""
print #1, "#define SURFACE_COLOR vec3(0.8,1.,0.8)*1.0"
print #1, ""
print #1, "#define horiz(s, e, p) if(s.x < p.x && p.x <= e.x) return mix(s.y, e.y, notsosmoothstep(0., 1., (p.x - s.x) / (e.x - s.x)));"
print #1, ""
print #1, "#define iterations 17"
print #1, "#define formuparam 0.53"
print #1, ""
print #1, "#define volsteps 20"
print #1, "#define stepsize 0.1"
print #1, ""
print #1, "#define zoom   0.800"
print #1, "#define tile   0.850"
print #1, "#define speed  0.010 "
print #1, ""
print #1, "#define brightness 0.0015"
print #1, "#define darkmatter 0.300"
print #1, "#define distfading 0.730"
print #1, "#define saturation 0.850"
print #1, ""
print #1, "#define D_DEMO_FREE"
print #1, ""
print #1, "#ifdef D_DEMO_FREE"
print #1, "    #define D_FOG_NOISE 1.0"
print #1, "    #define D_STRONG_FOG 0.0"
print #1, "    #define D_VOLUME_SHADOW_ENABLE 1"
print #1, "    #define D_USE_IMPROVE_INTEGRATION 1"
print #1, "#elif defined(D_DEMO_SHOW_IMPROVEMENT_FLAT)"
print #1, "    #define D_STRONG_FOG 10.0"
print #1, "    #define D_FOG_NOISE 0.0"
print #1, "	#define D_VOLUME_SHADOW_ENABLE 1"
print #1, "#elif defined(D_DEMO_SHOW_IMPROVEMENT_NOISE)"
print #1, "    #define D_STRONG_FOG 5.0"
print #1, "    #define D_FOG_NOISE 1.0"
print #1, "	#define D_VOLUME_SHADOW_ENABLE 1"
print #1, "#elif defined(D_DEMO_SHOW_IMPROVEMENT_FLAT_NOVOLUMETRICSHADOW)"
print #1, "    #define D_STRONG_FOG 10.0"
print #1, "    #define D_FOG_NOISE 0.0"
print #1, "	#define D_VOLUME_SHADOW_ENABLE 0"
print #1, "#elif defined(D_DEMO_SHOW_IMPROVEMENT_NOISE_NOVOLUMETRICSHADOW)"
print #1, "    #define D_STRONG_FOG 3.0"
print #1, "    #define D_FOG_NOISE 1.0"
print #1, "	#define D_VOLUME_SHADOW_ENABLE 0"
print #1, "#endif"
print #1, "#define D_UPDATE_TRANS_FIRST 0"
print #1, "#define D_DETAILED_WALLS 0"
print #1, "#define D_MAX_STEP_LENGTH_ENABLE 1"
print #1, "#define LPOS vec3( 20.0+15.0*sin(iTime), 15.0+12.0*cos(iTime),-20.0)"
print #1, "#define LCOL (600.0*vec3( 1.0, 0.9, 0.5))"
print #1, ""
print #1, "const float pi = PI;"
print #1, "const float maxHei = 0.8;"
print #1, "const vec3 sunDir = normalize( vec3(0.2,0.1,0.02) );"
print #1, ""
print #1, "vec3 LIGHT_DIR = normalize(vec3(-0.6,0.7,-0.3));"
print #1, ""
print #1, "vec4 ot;"
print #1, ""
print #1, "float kl = 0.0;"
print #1, ""
print #1, "int ef = 0;"
print #1, ""
print #1, "float seed = 0.0;"
print #1, "float href;"
print #1, "float hsha;"
print #1, ""
print #1, "struct CP {"
print #1, "    float dist;"
print #1, "    vec3 normal;"
print #1, "    float mat;"
print #1, "    vec3 p;"
print #1, "};"
print #1, "    "
print #1, "    "
print #1, "struct Ray {"
print #1, "    vec3 rd;"
print #1, "    CP cp;"
print #1, "    vec3 col;"
print #1, "    float share;"
print #1, "    float eta;"
print #1, "};"
print #1, ""
print #1, "//------------------------------------------------------------------"
print #1, ""
print #1, "float rand() { return fract(sin(seed++)*43758.5453123); }"
print #1, ""
print #1, "float rand(vec2 n) { "
print #1, "	return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);"
print #1, "}"
print #1, ""
print #1, "float rand1(vec2 co)"
print #1, "{"
print #1, "    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);"
print #1, "}"
print #1, ""
print #1, "float noise(vec2 n) {"
print #1, "	const vec2 d = vec2(0.0, 1.0);"
print #1, "	vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));"
print #1, "	return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);"
print #1, "}"
print #1, ""
print #1, "float noise(vec3 p) //Thx to Las^Mercury"
print #1, "{"
print #1, "	vec3 i = floor(p);"
print #1, "	vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);"
print #1, "	vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;"
print #1, "	a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);"
print #1, "	a.xy = mix(a.xz, a.yw, f.y);"
print #1, "	return mix(a.x, a.y, f.z);"
print #1, "}"
print #1, ""
print #1, "float smin( float a, float b, float k )"
print #1, "{"
print #1, "    float h = max(k-abs(a-b),0.0);"
print #1, "    return min(a, b) - h*h*0.25/k;"
print #1, "}"
print #1, ""
print #1, "vec2 smin( vec2 a, vec2 b, float k )"
print #1, "{"
print #1, "    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );"
print #1, "    return mix( b, a, h ) - k*h*(1.0-h);"
print #1, "}"
print #1, ""
print #1, "float smax( float a, float b, float k )"
print #1, "{"
print #1, "    float h = max(k-abs(a-b),0.0);"
print #1, "    return max(a, b) + h*h*0.25/k;"
print #1, "}"
print #1, ""
print #1, "vec3 rotXaxis(vec3 p, float rad)"
print #1, "{"
print #1, "	float z2 = cos(rad) * p.z - sin(rad) * p.y;"
print #1, "	float y2 = sin(rad) * p.z + cos(rad) * p.y;"
print #1, "	p.z = z2;"
print #1, "	p.y = y2;"
print #1, "	return p;"
print #1, "}"
print #1, ""
print #1, "vec3 rotYaxis(vec3 p, float rad) "
print #1, "{"
print #1, "	float x2 = cos(rad) * p.x - sin(rad) * p.z;"
print #1, "	float z2 = sin(rad) * p.x + cos(rad) * p.z;"
print #1, "	p.x = x2;"
print #1, "	p.z = z2;"
print #1, "	return p;"
print #1, "}"
print #1, ""
print #1, "//------------------------------------------------------------------"
print #1, ""
print #1, "float sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )"
print #1, "{"
print #1, "    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);"
print #1, "}"
print #1, ""
print #1, "float sdPlane( vec3 p )"
print #1, "{"
print #1, "	return p.y;"
print #1, "}"
print #1, ""
print #1, "float sdSphere( vec3 p, float s )"
print #1, "{"
print #1, "    return length(p)-s;"
print #1, "}"
print #1, ""
print #1, "float sphere(vec3 p, vec4 spr)"
print #1, "{"
print #1, "	return length(spr.xyz-p) - spr.w;"
print #1, "}"
print #1, ""
print #1, "float flame(vec3 p)"
print #1, "{"
print #1, "	float d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));"
print #1, "	return d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;"
print #1, "}"
print #1, ""
print #1, "float sdSphere( in vec3 p, in vec4 s )"
print #1, "{"
print #1, "    return length(p-s.xyz) - s.w;"
print #1, "}"
print #1, ""
print #1, "float sdBox( vec3 p, vec3 b )"
print #1, "{"
print #1, "    vec3 d = abs(p) - b;"
print #1, "    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));"
print #1, "}"
print #1, ""
print #1, "float Boxes(vec3 pos) "
print #1, "{"
print #1, "vec3 rok = vec3(0.35);"
print #1, "float m;"
print #1, "m = length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,0.0),iTime*0.3 ),iTime*0.15))-rok,0.0))-0.03; // Cube"
print #1, "m = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3, 1.2),iTime*0.21),iTime*0.24))-rok,0.0))-0.03); "
print #1, "m = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,-1.2),iTime*0.2 ),iTime*0.3 ))-rok,0.0))-0.03); "
print #1, "m = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(1.2,-0.3, 0.0),iTime*0.17),iTime*0.26))-rok,0.0))-0.03); "
print #1, "m = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(-1.2,-0.3,0.0),iTime*0.32),iTime*0.2 ))-rok,0.0))-0.03); "
print #1, "return m;"
print #1, "}"
print #1, ""
print #1, "float Singlebox(vec3 pos) "
print #1, "{"
print #1, "return length(max(abs(rotXaxis(pos+vec3(0.0,-0.5,0.0),iTime*0.47))-vec3(0.55-0.025*(kl+0.4)*sin(pos.z*pos.x*pos.y*35.)),0.0))-0.025; // Cube"
print #1, "}"
print #1, ""
print #1, "float sdEllipsoid( in vec3 p, in vec3 r ) // approximated"
print #1, "{"
print #1, "    float k0 = length(p/r);"
print #1, "    float k1 = length(p/(r*r));"
print #1, "    return k0*(k0-1.0)/k1;"
print #1, "    "
print #1, "}"
print #1, ""
print #1, "float udRoundBox( vec3 p, vec3 b, float r )"
print #1, "{"
print #1, "    return length(max(abs(p)-b,0.0))-r;"
print #1, "}"
print #1, ""
print #1, "float sdTorus( vec3 p, vec2 t )"
print #1, "{"
print #1, "    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;"
print #1, "}"
print #1, ""
print #1, "float sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)"
print #1, "{"
print #1, "    p.x = abs(p.x);"
print #1, "    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);"
print #1, "    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;"
print #1, "}"
print #1, ""
print #1, "float sdHexPrism( vec3 p, vec2 h )"
print #1, "{"
print #1, "    vec3 q = abs(p);"
print #1, "#if 0"
print #1, "    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);"
print #1, "#else"
print #1, "    float d1 = q.z-h.y;"
print #1, "    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;"
print #1, "    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);"
print #1, "#endif"
print #1, "}"
print #1, ""
print #1, "float sdCapsule( vec3 p, vec3 a, vec3 b, float r )"
print #1, "{"
print #1, "	vec3 pa = p-a, ba = b-a;"
print #1, "	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );"
print #1, "	return length( pa - ba*h ) - r;"
print #1, "}"
print #1, ""
print #1, "float sdRoundCone( in vec3 p, in float r1, float r2, float h )"
print #1, "{"
print #1, "    vec2 q = vec2( length(p.xz), p.y );"
print #1, "    "
print #1, "    float b = (r1-r2)/h;"
print #1, "    float a = sqrt(1.0-b*b);"
print #1, "    float k = dot(q,vec2(-b,a));"
print #1, "    "
print #1, "    if( k < 0.0 ) return length(q) - r1;"
print #1, "    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;"
print #1, "        "
print #1, "    return dot(q, vec2(a,b) ) - r1;"
print #1, "}"
print #1, ""
print #1, "float dot2(in vec3 v ) {return dot(v,v);}"
print #1, "float sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)"
print #1, "{"
print #1, "    // sampling independent computations (only depend on shape)"
print #1, "    vec3  ba = b - a;"
print #1, "    float l2 = dot(ba,ba);"
print #1, "    float rr = r1 - r2;"
print #1, "    float a2 = l2 - rr*rr;"
print #1, "    float il2 = 1.0/l2;"
print #1, "    "
print #1, "    // sampling dependant computations"
print #1, "    vec3 pa = p - a;"
print #1, "    float y = dot(pa,ba);"
print #1, "    float z = y - l2;"
print #1, "    float x2 = dot2( pa*l2 - ba*y );"
print #1, "    float y2 = y*y*l2;"
print #1, "    float z2 = z*z*l2;"
print #1, ""
print #1, "    // single square root!"
print #1, "    float k = sign(rr)*rr*rr*x2;"
print #1, "    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;"
print #1, "    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;"
print #1, "                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;"
print #1, "}"
print #1, ""
print #1, "float sdEquilateralTriangle(  in vec2 p )"
print #1, "{"
print #1, "    const float k = 1.73205;//sqrt(3.0);"
print #1, "    p.x = abs(p.x) - 1.0;"
print #1, "    p.y = p.y + 1.0/k;"
print #1, "    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;"
print #1, "    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );"
print #1, "    return -length(p)*sign(p.y);"
print #1, "}"
print #1, ""
print #1, "float sdTriPrism( vec3 p, vec2 h )"
print #1, "{"
print #1, "    vec3 q = abs(p);"
print #1, "#if 0"
print #1, "    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);"
print #1, "#else"
print #1, "    float d1 = q.z-h.y;"
print #1, "    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;"
print #1, "    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);"
print #1, "#endif"
print #1, "}"
print #1, ""
print #1, "// vertical"
print #1, "float sdCylinder( vec3 p, vec2 h )"
print #1, "{"
print #1, "    vec2 d = abs(vec2(length(p.xz),p.y)) - h;"
print #1, "    return min(max(d.x,d.y),0.0) + length(max(d,0.0));"
print #1, "}"
print #1, ""
print #1, "// arbitrary orientation"
print #1, "float sdCylinder(vec3 p, vec3 a, vec3 b, float r)"
print #1, "{"
print #1, "    vec3 pa = p - a;"
print #1, "    vec3 ba = b - a;"
print #1, "    float baba = dot(ba,ba);"
print #1, "    float paba = dot(pa,ba);"
print #1, ""
print #1, "    float x = length(pa*baba-ba*paba) - r*baba;"
print #1, "    float y = abs(paba-baba*0.5)-baba*0.5;"
print #1, "    float x2 = x*x;"
print #1, "    float y2 = y*y*baba;"
print #1, "    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));"
print #1, "    return sign(d)*sqrt(abs(d))/baba;"
print #1, "}"
print #1, ""
print #1, "float sdCappedCylinder( vec3 p, vec2 h )"
print #1, "{"
print #1, "  vec2 d = abs(vec2(length(p.xz),p.y)) - h;"
print #1, "  return min(max(d.x,d.y),0.0) + length(max(d,0.0));"
print #1, "}"
print #1, ""
print #1, "// vertical"
print #1, "float sdCone( in vec3 p, in vec3 c )"
print #1, "{"
print #1, "    vec2 q = vec2( length(p.xz), p.y );"
print #1, "    float d1 = -q.y-c.z;"
print #1, "    float d2 = max( dot(q,c.xy), q.y);"
print #1, "    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);"
print #1, "}"
print #1, ""
print #1, "float dot2( in vec2 v ) { return dot(v,v); }"
print #1, "float sdCone( in vec3 p, in float h, in float r1, in float r2 )"
print #1, "{"
print #1, "    vec2 q = vec2( length(p.xz), p.y );"
print #1, "    "
print #1, "    vec2 k1 = vec2(r2,h);"
print #1, "    vec2 k2 = vec2(r2-r1,2.0*h);"
print #1, "    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);"
print #1, "    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );"
print #1, "    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;"
print #1, "    return s*sqrt( min(dot2(ca),dot2(cb)) );"
print #1, "}"
print #1, ""
print #1, "float sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)"
print #1, "{"
print #1, "    float rba  = rb-ra;"
print #1, "    float baba = dot(b-a,b-a);"
print #1, "    float papa = dot(p-a,p-a);"
print #1, "    float paba = dot(p-a,b-a)/baba;"
print #1, ""
print #1, "    float x = sqrt( papa - paba*paba*baba );"
print #1, ""
print #1, "    float cax = max(0.0,x-((paba<0.5)?ra:rb));"
print #1, "    float cay = abs(paba-0.5)-0.5;"
print #1, ""
print #1, "    float k = rba*rba + baba;"
print #1, "    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );"
print #1, ""
print #1, "    float cbx = x-ra - f*rba;"
print #1, "    float cby = paba - f;"
print #1, "    "
print #1, "    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;"
print #1, "    "
print #1, "    return s*sqrt( min(cax*cax + cay*cay*baba,"
print #1, "                       cbx*cbx + cby*cby*baba) );"
print #1, "}"
print #1, ""
print #1, "float sdConeSection( in vec3 p, in float h, in float r1, in float r2 )"
print #1, "{"
print #1, "    float d1 = -p.y - h;"
print #1, "    float q = p.y - h;"
print #1, "    float si = 0.5*(r1-r2)/h;"
print #1, "    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );"
print #1, "    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);"
print #1, "}"
print #1, ""
print #1, "// c is the sin/cos of the desired cone angle"
print #1, "float sdSolidAngle(vec3 pos, vec2 c, float ra)"
print #1, "{"
print #1, "    vec2 p = vec2( length(pos.xz), pos.y );"
print #1, "    float l = length(p) - ra;"
print #1, "	float m = length(p - c*clamp(dot(p,c),0.0,ra) );"
print #1, "    return max(l,m*sign(c.y*p.x-c.x*p.y));"
print #1, "}"
print #1, ""
print #1, "float sdOctahedron(vec3 p, float s)"
print #1, "{"
print #1, "    p = abs(p);"
print #1, "    float m = p.x + p.y + p.z - s;"
print #1, ""
print #1, "    // exact distance"
print #1, "    #if 0"
print #1, "    vec3 o = min(3.0*p - m, 0.0);"
print #1, "    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);"
print #1, "    return length(p - s*o/(o.x+o.y+o.z));"
print #1, "    #endif"
print #1, "    "
print #1, "    // exact distance"
print #1, "    #if 1"
print #1, " 	vec3 q;"
print #1, "         if( 3.0*p.x < m ) q = p.xyz;"
print #1, "    else if( 3.0*p.y < m ) q = p.yzx;"
print #1, "    else if( 3.0*p.z < m ) q = p.zxy;"
print #1, "    else return m*0.57735027;"
print #1, "    float k = clamp(0.5*(q.z-q.y+s),0.0,s); "
print #1, "    return length(vec3(q.x,q.y-s+k,q.z-k)); "
print #1, "    #endif"
print #1, "    "
print #1, "    // bound, not exact"
print #1, "    #if 0"
print #1, "	return m*0.57735027;"
print #1, "    #endif"
print #1, "}"
print #1, ""
print #1, "float sdPyramid( in vec3 p, in float h )"
print #1, "{"
print #1, "    float m2 = h*h + 0.25;"
print #1, "    "
print #1, "    // symmetry"
print #1, "    p.xz = abs(p.xz);"
print #1, "    p.xz = (p.z>p.x) ? p.zx : p.xz;"
print #1, "    p.xz -= 0.5;"
print #1, "	"
print #1, "    // project into face plane (2D)"
print #1, "    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);"
print #1, "   "
print #1, "    float s = max(-q.x,0.0);"
print #1, "    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );"
print #1, "    "
print #1, "    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;"
print #1, "	float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);"
print #1, "    "
print #1, "    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);"
print #1, "    "
print #1, "    // recover 3D and scale, and add sign"
print #1, "    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;"
print #1, "}"
print #1, ""
print #1, "float sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }"
print #1, "{"
print #1, "    // Tetrahedron = Octahedron - Cube"
print #1, "    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );"
print #1, "    float d = 0.0;"
print #1, "    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));"
print #1, "    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));"
print #1, "    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));"
print #1, "    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));"
print #1, "    float octa = d - h.z;"
print #1, "    return max(-box,octa); // Subtraction"
print #1, "}"
print #1, ""
print #1, "vec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated"
print #1, "{"
print #1, "    vec3 pa = p-a, ba = b-a;"
print #1, "	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );"
print #1, "	return vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );"
print #1, "}"
print #1, ""
print #1, "float sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )"
print #1, "{"
print #1, "	vec2 e0 = p1 - p0;"
print #1, "	vec2 e1 = p2 - p1;"
print #1, "	vec2 e2 = p0 - p2;"
print #1, ""
print #1, "	vec2 v0 = p - p0;"
print #1, "	vec2 v1 = p - p1;"
print #1, "	vec2 v2 = p - p2;"
print #1, ""
print #1, "	vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );"
print #1, "	vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );"
print #1, "	vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );"
print #1, "    "
print #1, "    float s = sign( e0.x*e2.y - e0.y*e2.x );"
print #1, "    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),"
print #1, "                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),"
print #1, "                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));"
print #1, ""
print #1, "	return -sqrt(d.x)*sign(d.y);"
print #1, "}"
print #1, ""
print #1, "float menger(vec3 pos )"
print #1, "{"
print #1, "	float d = sdBox(pos,vec3(1.));"
print #1, "	float s = 1.63+0.07*sin(0.53*iTime)-0.3*pos.y;"
print #1, "	for( int m=0; m<2; m++ )"
print #1, "	{"
print #1, "      vec3 a = mod( pos*s, 2.0 )-1.0;"
print #1, "      s *= 3.0;"
print #1, "	  vec3 r = abs(1.0 - 3.0*abs(a))-0.025;"
print #1, "      float da = max(r.x,r.y);"
print #1, "      float db = max(r.y,r.z);"
print #1, "      float dc = max(r.z,r.x);"
print #1, "      float c = (min(da,min(db,dc))-1.0)/s;"
print #1, "      d = max(d,c);"
print #1, "   }"
print #1, "    return d;"
print #1, "}"
print #1, ""
print #1, "vec3 hsv2rgb_smooth( in vec3 c )"
print #1, "{"
print #1, "    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );"
print #1, "	rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing	"
print #1, "	return c.z * mix( vec3(1.0), rgb, c.y);"
print #1, "}"
print #1, ""
print #1, "float notsosmoothstep(float edge0, float edge1, float x)"
print #1, "{"
print #1, "    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0); "
print #1, "    return mix(x*x*(3. - 2.*x), x, 0.2);"
print #1, "}"
print #1, ""
print #1, "float length2( vec2 p )"
print #1, "{"
print #1, "    return sqrt( p.x*p.x + p.y*p.y );"
print #1, "}"
print #1, ""
print #1, "float length6( vec2 p )"
print #1, "{"
print #1, "    p = p*p*p; p = p*p;"
print #1, "    return pow( p.x + p.y, 1.0/6.0 );"
print #1, "}"
print #1, ""
print #1, "float length8( vec2 p )"
print #1, "{"
print #1, "    p = p*p; p = p*p; p = p*p;"
print #1, "    return pow( p.x + p.y, 1.0/8.0 );"
print #1, "}"
print #1, ""
print #1, "float sdTorus82( vec3 p, vec2 t )"
print #1, "{"
print #1, "    vec2 q = vec2(length2(p.xz)-t.x,p.y);"
print #1, "    return length8(q)-t.y;"
print #1, "}"
print #1, ""
print #1, "float sdTorus88( vec3 p, vec2 t )"
print #1, "{"
print #1, "    vec2 q = vec2(length8(p.xz)-t.x,p.y);"
print #1, "    return length8(q)-t.y;"
print #1, "}"
print #1, ""
print #1, "float sdCylinder6( vec3 p, vec2 h )"
print #1, "{"
print #1, "    return max( length6(p.xz)-h.x, abs(p.y)-h.y );"
print #1, "}"
print #1, ""
print #1, "//------------------------------------------------------------------"
print #1, ""
print #1, "float opS( float d1, float d2 )"
print #1, "{"
print #1, "    return max(-d2,d1);"
print #1, "}"
print #1, ""
print #1, "vec3 opS(  vec3 d1, vec3 d2 )"
print #1, "{"
print #1, "    return -d1.x>d2.x ? d2: d1;"
print #1, "}"
print #1, ""
print #1, "vec2 opU( vec2 d1, vec2 d2 )"
print #1, "{"
print #1, "	return (d1.x<d2.x) ? d1 : d2;"
print #1, "}"
print #1, ""
print #1, "vec3 opU( vec3 d1, vec3 d2 )"
print #1, "{"
print #1, "   "
print #1, "	return (d1.x<d2.x) ? d1 : d2;"
print #1, "}"
print #1, ""
print #1, "vec4 opU( vec4 d1, vec4 d2 )"
print #1, "{"
print #1, "	return (d1.x<d2.x) ? d1 : d2;"
print #1, "}"
print #1, ""
print #1, "vec3 opRep( vec3 p, vec3 c )"
print #1, "{"
print #1, "    return mod(p,c)-0.5*c;"
print #1, "}"
print #1, ""
print #1, "vec3 opTwist( vec3 p )"
print #1, "{"
print #1, "    float  c = cos(10.0*p.y+10.0);"
print #1, "    float  s = sin(10.0*p.y+10.0);"
print #1, "    mat2   m = mat2(c,-s,s,c);"
print #1, "    return vec3(m*p.xz,p.y);"
print #1, "}"
print #1, ""
print #1, "float sdCircle( in vec2 p, in vec2 c, in float r )"
print #1, "{"
print #1, "    return length(p-c) - r;"
print #1, "}"
print #1, ""
print #1, "vec2 udSegment( vec3 p, vec3 a, vec3 b )"
print #1, "{"
print #1, "	vec3 pa = p-a, ba = b-a;"
print #1, "	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );"
print #1, "	return vec2( length( pa - ba*h ), h );"
print #1, "}"
print #1, ""
print #1, "float det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }"
print #1, "vec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) "
print #1, "{"
print #1, "    float a =     det(b0,b2);"
print #1, "    float b = 2.0*det(b1,b0);"
print #1, "    float d = 2.0*det(b2,b1);"
print #1, "    float f = b*d - a*a;"
print #1, "    vec2  d21 = b2-b1;"
print #1, "    vec2  d10 = b1-b0;"
print #1, "    vec2  d20 = b2-b0;"
print #1, "    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);"
print #1, "    vec2  pp = -f*gf/dot(gf,gf);"
print #1, "    vec2  d0p = b0-pp;"
print #1, "    float ap = det(d0p,d20);"
print #1, "    float bp = 2.0*det(d10,d0p);"
print #1, "    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );"
print #1, "    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );"
print #1, "}"
print #1, ""
print #1, "vec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )"
print #1, "{"
print #1, "	vec3 w = normalize( cross( c-b, a-b ) );"
print #1, "	vec3 u = normalize( c-b );"
print #1, "	vec3 v =          ( cross( w, u ) );"
print #1, ""
print #1, "	vec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );"
print #1, "	vec2 b2 = vec2( 0.0 );"
print #1, "	vec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );"
print #1, "	vec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );"
print #1, ""
print #1, "	vec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );"
print #1, ""
print #1, "	return vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );"
print #1, "}"
print #1, ""
print #1, "vec3 smax( vec3 a, vec3 b, float k )"
print #1, "{"
print #1, "	vec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );"
print #1, "	return mix( a, b, h ) + k*h*(1.0-h);"
print #1, "}"
print #1, ""
print #1, "//---------------------------------------------------------------------------"
print #1, ""
print #1, "float hash1( float n )"
print #1, "{"
print #1, "    return fract(sin(n)*43758.5453123);"
print #1, "}"
print #1, ""
print #1, "vec3 hash3( float n )"
print #1, "{"
print #1, "    return fract(sin(n+vec3(0.0,13.1,31.3))*158.5453123);"
print #1, "}"
print #1, ""
print #1, "vec3 forwardSF( float i, float n) "
print #1, "{"
print #1, "    const float PHI = PI*0.5;"
print #1, "    float phi = 2.0*PI*fract(i/PHI);"
print #1, "    float zi = 1.0 - (2.0*i+1.0)/n;"
print #1, "    float sinTheta = sqrt( 1.0 - zi*zi);"
print #1, "    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);"
print #1, "}"
print #1, ""
print #1, "vec3 map3(in vec3 pos) {"
print #1, "    "
print #1, "    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);"
print #1, "    res.x =abs(res.x);"
print #1, "    res = opU(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); "
print #1, "    res.x =abs(res.x);"
print #1, "	return res;"
print #1, "}"
print #1, ""
print #1, "vec3 map4(in vec3 pos) {"
print #1, "    "
print #1, "    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);"
print #1, "    res = opU(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); "
print #1, "    res.x =abs(res.x);"
print #1, "	return res;"
print #1, "}"
print #1, ""
print #1, "vec3 map2(in vec3 pos) {"
print #1, "   vec3 res =  vec3((sdCappedCylinder(pos-vec3(0,0.4,0), vec2(0.8,0.5))), ID_GLASS_WALL, ETA);"
print #1, "    res = opS(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); "
print #1, "    res.x =abs(res.x);"
print #1, " 	return res;"
print #1, "}"
print #1, ""
print #1, "vec3 map1(in vec3 pos) {"
print #1, "    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);"
print #1, "    res = opS(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); "
print #1, "    res.x =abs(res.x);"
print #1, " 	return res;"
print #1, "}"
print #1, ""
print #1, "vec3 map(in vec3 pos) {"
print #1, "    vec3 plane = vec3(sdPlane(pos), ID_FLOOR, -1. );"
print #1, ""
print #1, "    vec3 res = plane;"
print #1, "#ifdef OBJECT_MAP_FUNCTION    "
print #1, "	res =opU(res, OBJECT_MAP_FUNCTION(pos));    "
print #1, "#else"
print #1, "    float t = mod(iTime*0.1, 4.);"
print #1, "    if (t < 1.) {"
print #1, "    	res = opU(res, map1(pos));"
print #1, "    } else if (t<2.) {"
print #1, "       	res = opU(res, map2(pos));"
print #1, "    } else if (t<3.) {"
print #1, "        res = opU(res, map3(pos));"
print #1, "    } else if (t<4.) {"
print #1, "        res = opU(res, map4(pos));"
print #1, "    }"
print #1, "#endif"
print #1, "    return res;"
print #1, "}"
print #1, ""
print #1, "vec4 map( in vec3 pos, float atime )"
print #1, "{"
print #1, "    hsha = 1.0;"
print #1, "    "
print #1, "    float t1 = fract(atime);"
print #1, "    float t4 = abs(fract(atime*0.5)-0.5)/0.5;"
print #1, ""
print #1, "    float p = 4.0*t1*(1.0-t1);"
print #1, "    float pp = 4.0*(1.0-2.0*t1); // derivative of p"
print #1, ""
print #1, "    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),"
print #1, "                     pow(p,2.0-p) + 0.1,"
print #1, "                     floor(atime) + pow(t1,0.7) -1.0 );"
print #1, ""
print #1, "    // body"
print #1, "    vec2 uu = normalize(vec2( 1.0, -pp ));"
print #1, "    vec2 vv = vec2(-uu.y, uu.x);"
print #1, "    "
print #1, "    float sy = 0.5 + 0.5*p;"
print #1, "    float compress = 1.0-smoothstep(0.0,0.4,p);"
print #1, "    sy = sy*(1.0-compress) + compress;"
print #1, "    float sz = 1.0/sy;"
print #1, ""
print #1, "    vec3 q = pos - cen;"
print #1, "    float rot = -0.25*(-1.0 + 2.0*t4);"
print #1, "    float rc = cos(rot);"
print #1, "    float rs = sin(rot);"
print #1, "    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;"
print #1, "    vec3 r = q;"
print #1, "	href = q.y;"
print #1, "    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );"
print #1, "    "
print #1, "    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );"
print #1, ""
print #1, "    if( res.x-1.0 < pos.y ) // bounding volume"
print #1, "	{"
print #1, "    float t2 = fract(atime+0.8);"
print #1, "    float p2 = 0.5-0.5*cos(6.2831*t2);"
print #1, "    r.z += 0.05-0.2*p2;"
print #1, "    r.y += 0.2*sy-0.2;"
print #1, "    vec3 sq = vec3( abs(r.x), r.yz );"
print #1, ""
print #1, "	// head"
print #1, "    vec3 h = r;"
print #1, "    float hr = sin(0.791*atime);"
print #1, "    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));"
print #1, "    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;"
print #1, "    vec3 hq = vec3( abs(h.x), h.yz );"
print #1, "   	float d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );"
print #1, "	float d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );"
print #1, "	d = smin( d, d2, 0.1 );"
print #1, "    res.x = smin( res.x, d, 0.1 );"
print #1, "    "
print #1, "    // belly wrinkles"
print #1, "    {"
print #1, "    float yy = r.y-0.02-2.5*r.x*r.x;"
print #1, "    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));"
print #1, "    }"
print #1, "        "
print #1, "    // arms"
print #1, "    {"
print #1, "    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );"
print #1, "    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );"
print #1, "    }"
print #1, "        "
print #1, "    // ears"
print #1, "    {"
print #1, "    float t3 = fract(atime+0.9);"
print #1, "    float p3 = 4.0*t3*(1.0-t3);"
print #1, "    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );"
print #1, "    res.xz = smin( res.xz, ear, 0.01 );"
print #1, "    }"
print #1, "    "
print #1, "    // mouth"
print #1, "    {"
print #1, "   	d = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );"
print #1, "    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);"
print #1, "    res.x = smax( res.x, -d, 0.03 );"
print #1, "    }"
print #1, ""
print #1, "	// legs"
print #1, "    {"
print #1, "    float t6 = cos(6.2831*(atime*0.5+0.25));"
print #1, "    float ccc = cos(1.57*t6*sign(r.x));"
print #1, "    float sss = sin(1.57*t6*sign(r.x));"
print #1, "	vec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;"
print #1, "    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );"
print #1, "    res.xz = smin( res.xz, legs, 0.07 );"
print #1, "    }"
print #1, "        "
print #1, "    // eye"
print #1, "    {"
print #1, "    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);"
print #1, "    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);"
print #1, "    res.x = smin( res.x, eyeball, 0.03 );"
print #1, "    "
print #1, "    vec3 cq = hq-vec3(0.1,0.34,0.08);"
print #1, "    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;"
print #1, "    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );"
print #1, "    res.x = smin( res.x, d, 0.03 );"
print #1, ""
print #1, "    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));"
print #1, "    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));"
print #1, "    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));"
print #1, "    }"
print #1, "	}"
print #1, "    "
print #1, "    // ground"
print #1, "    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));"
print #1, "    float t5 = fract(atime+0.05);"
print #1, "    float k = length(pos.xz-cen.xz);"
print #1, "    float tt = t5*15.0-6.2831 - k*3.0;"
print #1, "    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5);"
print #1, "    float d = pos.y - fh;"
print #1, "    "
print #1, "    // bubbles"
print #1, "    {"
print #1, "    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);"
print #1, "    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );"
print #1, "    float fid = id.x*11.1 + id.y*31.7;"
print #1, "    float fy = fract(fid*1.312+atime*0.1);"
print #1, "    float y = -1.0+4.0*fy;"
print #1, "    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);"
print #1, "    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    "
print #1, "    float siz = 4.0*fy*(1.0-fy);"
print #1, "    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );"
print #1, "    "
print #1, "    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));"
print #1, "    d2 *= 0.6;"
print #1, "    d2 = min(d2,2.0);"
print #1, "    d = smin( d, d2, 0.32 );"
print #1, "    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }"
print #1, "    }"
print #1, ""
print #1, "    // candy"
print #1, "    {"
print #1, "    float fs = 5.0;"
print #1, "    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );"
print #1, "    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );"
print #1, "    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);"
print #1, "    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );"
print #1, "    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);"
print #1, "    float fid = id.x*0.143 + id.y*0.372;"
print #1, "    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);"
print #1, "    d = sdSphere( vp, 0.35*ra )/fs;"
print #1, "    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);"
print #1, "    }"
print #1, "    "
print #1, "    return res;"
print #1, "}"
print #1, ""
print #1, "vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) "
print #1, "{"
print #1, "    vec3 m = 1.0/rd;"
print #1, "    vec3 n = m*ro;"
print #1, "    vec3 k = abs(m)*rad;"
print #1, "    vec3 t1 = -n - k;"
print #1, "    vec3 t2 = -n + k;"
print #1, "	return vec2( max( max( t1.x, t1.y ), t1.z ),"
print #1, "	             min( min( t2.x, t2.y ), t2.z ) );"
print #1, "}"
print #1, ""
print #1, "float mapShell( in vec3 p, out vec4 matInfo ) "
print #1, "{"
print #1, "    "
print #1, "    const float sc = 1.0/1.0;"
print #1, "    p -= vec3(0.05,0.12,-0.09);    "
print #1, ""
print #1, "    p *= sc;"
print #1, ""
print #1, "    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,"
print #1, "                   0.7738444477, -0.6034162289, 0.1924931824,"
print #1, "                   0.0081370606,  0.3133626215, 0.9495986813) * p;"
print #1, ""
print #1, "    const float b = 0.1759;"
print #1, "    "
print #1, "    float r = length( q.xy );"
print #1, "    float t = atan( q.y, q.x );"
print #1, " "
print #1, "    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/"
print #1, "    float n = (log(r)/b - t)/(2.0*pi);"
print #1, ""
print #1, "    const float th = 0.11;"
print #1, "    float nm = (log(th)/b-t)/(2.0*pi);"
print #1, ""
print #1, "    n = min(n,nm);"
print #1, "    "
print #1, "    float ni = floor( n );"
print #1, "    "
print #1, "    float r1 = exp( b * (t + 2.0*pi*ni));"
print #1, "    float r2 = r1 * 3.019863;"
print #1, "    "
print #1, "    //-------"
print #1, ""
print #1, "    float h1 = q.z + 1.5*r1 - 0.5; float d1 = sqrt((r1-r)*(r1-r)+h1*h1) - r1;"
print #1, "    float h2 = q.z + 1.5*r2 - 0.5; float d2 = sqrt((r2-r)*(r2-r)+h2*h2) - r2;"
print #1, "    "
print #1, "    float d, dx, dy;"
print #1, "    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }"
print #1, "    else        { d = d2; dx=r2-r; dy=h2; }"
print #1, ""
print #1, ""
print #1, "    float di = textureLod( iChannel2, vec2(t+r,0.5), 0. ).x;"
print #1, "    d += 0.002*di;"
print #1, "    "
print #1, "    matInfo = vec4(dx,dy,r/0.4,t/3.14159);"
print #1, ""
print #1, "    vec3 s = q;"
print #1, "    q = q - vec3(0.34,-0.1,0.03);"
print #1, "    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;"
print #1, "    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);"
print #1, "    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );"
print #1, ""
print #1, "    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );"
print #1, "    "
print #1, "    return d/sc;"
print #1, "}"
print #1, ""
print #1, "vec2 mapSnail( vec3 p, out vec4 matInfo )"
print #1, "{"
print #1, "    vec3 head = vec3(-0.76,0.6,-0.3);"
print #1, "    "
print #1, "    vec3 q = p - head;"
print #1, ""
print #1, "    // body"
print #1, "#if 1"
print #1, "    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.1,0.0), head+vec3(0.04,0.01,0.0), p );"
print #1, "    float d1 = b1.x;"
print #1, "    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));"
print #1, "    b1 = sdBezier( vec3(-0.085,0.0,0.0), vec3(-0.1,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );"
print #1, "    float d2 = b1.x;"
print #1, "    d2 -= 0.1 - 0.06*b1.y;"
print #1, "    d1 = smin( d1, d2, 0.03 );"
print #1, "    matInfo.xyz = b1.yzw;"
print #1, "#else"
print #1, "    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.11,0.0), head+vec3(0.05,0.01-0.02,0.0), p );"
print #1, "    float d1 = b1.x;"
print #1, "    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.75*0.07*smoothstep(0.5,1.0,b1.y));"
print #1, "    matInfo.xyz = b1.yzw;"
print #1, "    float d2;"
print #1, "#endif"
print #1, "    d2 = sdSphere( q, vec4(0.0,-0.06,0.0,0.085) );"
print #1, "    d1 = smin( d1, d2, 0.03 );"
print #1, "    "
print #1, "    d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );"
print #1, "    "
print #1, "    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;"
print #1, ""
print #1, "    vec3 sq = vec3( q.xy, abs(q.z) );"
print #1, "    "
print #1, "    // top antenas"
print #1, "    vec3 af = 0.05*sin(0.5*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );"
print #1, "    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );"
print #1, "    float d3 = b2.x;"
print #1, "    d3 -= 0.03 - 0.025*b2.y;"
print #1, "    d1 = smin( d1, d3, 0.04 );"
print #1, "    d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.016) + vec4(af,0.0) );"
print #1, "    d1 = smin( d1, d3, 0.01 );    "
print #1, "    "
print #1, "    // bottom antenas"
print #1, "    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );"
print #1, "    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.2,0.18)+bf );"
print #1, "    d3 = b3.x;"
print #1, "    d3 -= 0.025 - 0.02*b3.y;"
print #1, "    d1 = smin( d1, d3, 0.06 );"
print #1, "    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );"
print #1, "    d1 = smin( d1, d3, 0.02 );"
print #1, "    "
print #1, "    // bottom"
print #1, "    vec3 pp = p-vec3(-0.17,0.15,0.0);"
print #1, "    float co = 0.988771078;"
print #1, "    float si = 0.149438132;"
print #1, "    pp.xy = mat2(co,-si,si,co)*pp.xy;"
print #1, "    d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );"
print #1, "    d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );"
print #1, "    "
print #1, "    // disp"
print #1, "    float dis = textureLod( iChannel1, 5.0*p.xy, 0. ).x;"
print #1, "    float dx = 0.5 + 0.5*(1.0-smoothstep(0.5,1.0,b1.y));"
print #1, "    d1 -= 0.005*dis*dx*0.5;"
print #1, "        "
print #1, "    return vec2(d1,1.0);"
print #1, "}"
print #1, "    "
print #1, "float mapDrop( in vec3 p )"
print #1, "{"
print #1, "    p -= vec3(-0.26,0.25,-0.02);"
print #1, "    p.x -= 2.5*p.y*p.y;"
print #1, "    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );"
print #1, "}"
print #1, ""
print #1, "float mapLeaf( in vec3 p )"
print #1, "{"
print #1, "    p -= vec3(-1.8,0.6,-0.75);"
print #1, "    "
print #1, "    p = mat3(0.671212, 0.366685, -0.644218,"
print #1, "            -0.479426, 0.877583,  0.000000,"
print #1, "             0.565354, 0.308854,  0.764842)*p;"
print #1, " "
print #1, "    p.y += 0.2*exp(-abs(2.0*p.z) );"
print #1, "    "
print #1, "    "
print #1, "    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);// + 1.0*sin(5.0*p.x)*sin(5.0*p.z);"
print #1, "    float rr = sin( ph );"
print #1, "    rr = rr*rr;    "
print #1, "    rr = rr*rr;    "
print #1, "    p.y += 0.005*rr;"
print #1, "    "
print #1, "    float r = clamp((p.x+2.0)/4.0,0.0,1.0);"
print #1, "    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;"
print #1, "    "
print #1, "    rr = sin( ph*2.0 );"
print #1, "    rr = rr*rr;    "
print #1, "    rr *= 0.5+0.5*sin( p.x*12.0 );"
print #1, ""
print #1, "    float ri = 0.035*rr;"
print #1, "    "
print #1, "    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );"
print #1, ""
print #1, "    float d2 = p.y-0.02;"
print #1, "    d = smax( d, -d2, 0.02 );"
print #1, "    "
print #1, "    return d;"
print #1, "}"
print #1, ""
print #1, "vec2 mapOpaque( vec3 p, out vec4 matInfo )"
print #1, "{"
print #1, "    matInfo = vec4(0.0);"
print #1, "    "
print #1, "   	//--------------"
print #1, "    vec2 res = mapSnail( p, matInfo );"
print #1, "    "
print #1, "    //---------------"
print #1, "    vec4 tmpMatInfo;"
print #1, "    float d4 = mapShell( p, tmpMatInfo );    "
print #1, "    if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }"
print #1, ""
print #1, "    //---------------"
print #1, "    "
print #1, "    // plant"
print #1, "    vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );"
print #1, "    d4 = b3.x;"
print #1, "    d4 -= 0.04 - 0.02*b3.y;"
print #1, "    if( d4<res.x  ) { res = vec2(d4,3.0); }"
print #1, "	"
print #1, "	//----------------------------"
print #1, "    "
print #1, "    float d5 = mapLeaf( p );"
print #1, "    if( d5<res.x ) res = vec2(d5,4.0);"
print #1, "        "
print #1, "    return res;"
print #1, "}"
print #1, ""
print #1, ""
print #1, "vec3 calcNormalOpaque( in vec3 pos, in float eps )"
print #1, "{"
print #1, "    vec4 kk;"
print #1, "#if 0"
print #1, "    vec2 e = vec2(1.0,-1.0)*0.5773*eps;"
print #1, "    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + "
print #1, "					  e.yyx*mapOpaque( pos + e.yyx, kk ).x + "
print #1, "					  e.yxy*mapOpaque( pos + e.yxy, kk ).x + "
print #1, "					  e.xxx*mapOpaque( pos + e.xxx, kk ).x );"
print #1, "#else"
print #1, "    // inspired by klems - a way to prevent the compiler from inlining map() 4 times"
print #1, "    vec3 n = vec3(0.0);"
print #1, "    for( int i=ZERO; i<4; i++ )"
print #1, "    {"
print #1, "        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);"
print #1, "        n += e*mapOpaque(pos+eps*e,kk).x;"
print #1, "    }"
print #1, "    return normalize(n);"
print #1, "#endif    "
print #1, "}"
print #1, ""
print #1, "//========================================================================="
print #1, ""
print #1, "float mapLeafWaterDrops( in vec3 p )"
print #1, "{"
print #1, "    p -= vec3(-1.8,0.6,-0.75);"
print #1, "    vec3 s = p;"
print #1, "    p = mat3(0.671212, 0.366685, -0.644218,"
print #1, "            -0.479426, 0.877583,  0.000000,"
print #1, "             0.565354, 0.308854,  0.764842)*p;"
print #1, "  "
print #1, "    vec3 q = p;"
print #1, "    p.y += 0.2*exp(-abs(2.0*p.z) );"
print #1, "    "
print #1, "    //---------------"
print #1, "    "
print #1, "    float r = clamp((p.x+2.0)/4.0,0.0,1.0);"
print #1, "    r = r*(1.0-r)*(1.0-r)*6.0;"
print #1, "    float d0 = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r) );"
print #1, "    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );"
print #1, "    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );"
print #1, "    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );"
print #1, "    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );"
print #1, ""
print #1, "    d3 = max( d3, p.y-0.01);"
print #1, "    "
print #1, "    return min( min(d1,d4), min(d2,d3) );"
print #1, "}"
print #1, ""
print #1, "vec2 mapTransparent( vec3 p, out vec4 matInfo )"
print #1, "{"
print #1, "    matInfo = vec4(0.0);"
print #1, "    "
print #1, "    float d5 = mapDrop( p );"
print #1, "    vec2  res = vec2(d5,4.0);"
print #1, ""
print #1, "    float d6 = mapLeafWaterDrops( p );"
print #1, "    res.x = min( res.x, d6 );"
print #1, ""
print #1, "    return res;"
print #1, "}"
print #1, ""
print #1, "vec3 calcNormalTransparent( in vec3 pos, in float eps )"
print #1, "{"
print #1, "    vec4 kk;"
print #1, "    vec2 e = vec2(1.0,-1.0)*0.5773*eps;"
print #1, "    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + "
print #1, "					  e.yyx*mapTransparent( pos + e.yyx, kk ).x + "
print #1, "					  e.yxy*mapTransparent( pos + e.yxy, kk ).x + "
print #1, "					  e.xxx*mapTransparent( pos + e.xxx, kk ).x );"
print #1, "}"
print #1, ""
print #1, "float calcAO( in vec3 pos, in vec3 nor )"
print #1, "{"
print #1, "    vec4 kk;"
print #1, "	float ao = 0.0;"
print #1, "    for( int i=ZERO; i<32; i++ )"
print #1, "    {"
print #1, "        vec3 ap = forwardSF( float(i), 32.0 );"
print #1, "        float h = hash1(float(i));"
print #1, "		ap *= sign( dot(ap,nor) ) * h*0.1;"
print #1, "        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );"
print #1, "    }"
print #1, "	ao /= 32.0;"
print #1, "	"
print #1, "    return clamp( ao*6.0, 0.0, 1.0 );"
print #1, "}"
print #1, ""
print #1, "float calcSSS( in vec3 pos, in vec3 nor )"
print #1, "{"
print #1, "    vec4 kk;"
print #1, "	float occ = 0.0;"
print #1, "    for( int i=ZERO; i<8; i++ )"
print #1, "    {"
print #1, "        float h = 0.002 + 0.11*float(i)/7.0;"
print #1, "        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );"
print #1, "        dir *= sign(dot(dir,nor));"
print #1, "        occ += (h-mapOpaque(pos-h*dir, kk).x);"
print #1, "    }"
print #1, "    occ = clamp( 1.0 - 11.0*occ/8.0, 0.0, 1.0 );    "
print #1, "    return occ*occ;"
print #1, "}"
print #1, ""
print #1, "float calcSoftshadow( in vec3 ro, in vec3 rd, float time )"
print #1, "{"
print #1, "    float res = 1.0;"
print #1, ""
print #1, "    float tmax = 12.0;"
print #1, "    #if 1"
print #1, "    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane"
print #1, "    if( tp>0.0 ) tmax = min( tmax, tp );"
print #1, "	#endif    "
print #1, "    "
print #1, "    float t = 0.02;"
print #1, "    for( int i=0; i<50; i++ )"
print #1, "    {"
print #1, "		float h = map( ro + rd*t, time ).x;"
print #1, "        res = min( res, mix(1.0,16.0*h/t, hsha) );"
print #1, "        t += clamp( h, 0.05, 0.40 );"
print #1, "        if( res<0.005 || t>tmax ) break;"
print #1, "    }"
print #1, "    return clamp( res, 0.0, 1.0 );"
print #1, "}"
print #1, ""
print #1, "vec3 calcNormal( in vec3 pos, float time )"
print #1, "{"
print #1, "    "
print #1, "#if 0"
print #1, "    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;"
print #1, "    return normalize( e.xyy*map( pos + e.xyy, time ).x + "
print #1, "					  e.yyx*map( pos + e.yyx, time ).x + "
print #1, "					  e.yxy*map( pos + e.yxy, time ).x + "
print #1, "					  e.xxx*map( pos + e.xxx, time ).x );"
print #1, "#else"
print #1, "    // inspired by klems - a way to prevent the compiler from inlining map() 4 times"
print #1, "    vec3 n = vec3(0.0);"
print #1, "    for( int i=ZERO; i<4; i++ )"
print #1, "    {"
print #1, "        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);"
print #1, "        n += e*map(pos+0.001*e,time).x;"
print #1, "    }"
print #1, "    return normalize(n);"
print #1, "#endif    "
print #1, "}"
print #1, ""
print #1, "vec3 jitter(vec3 d, float phi, float sina, float cosa) {"
print #1, "    vec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);"
print #1, "    return (u*cos(phi) + v*sin(phi)) * sina + w * cosa;"
print #1, "}"
print #1, ""
print #1, "float calcOcclusion( in vec3 pos, in vec3 nor, float time )"
print #1, "{"
print #1, "	float occ = 0.0;"
print #1, "    float sca = 1.0;"
print #1, "    for( int i=ZERO; i<5; i++ )"
print #1, "    {"
print #1, "        float h = 0.01 + 0.11*float(i)/4.0;"
print #1, "        vec3 opos = pos + h*nor;"
print #1, "        float d = map( opos, time ).x;"
print #1, "        occ += (h-d)*sca;"
print #1, "        sca *= 0.95;"
print #1, "    }"
print #1, "    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );"
print #1, "}"
print #1, ""
print #1, "float calcSoftShadow( in vec3 ro, in vec3 rd, float k )"
print #1, "{"
print #1, "    vec4 kk;    "
print #1, "    float res = 1.0;"
print #1, "    float t = 0.01;"
print #1, "    for( int i=ZERO; i<32; i++ )"
print #1, "    {"
print #1, "        float h = mapOpaque(ro + rd*t, kk ).x;"
print #1, "        res = min( res, smoothstep(0.0,1.0,k*h/t) );"
print #1, "        t += clamp( h, 0.04, 0.1 );"
print #1, "		if( res<0.01 ) break;"
print #1, "    }"
print #1, "    return clamp(res,0.0,1.0);"
print #1, "}"
print #1, ""
print #1, "float checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )"
print #1, "{"
print #1, "    // filter kernel"
print #1, "    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;"
print #1, "    // analytical integral (box filter)"
print #1, "    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;"
print #1, "    // xor pattern"
print #1, "    return 0.5 - 0.5*i.x*i.y;                  "
print #1, "}"
print #1, ""
print #1, "vec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )"
print #1, "{"
print #1, "    float eps = 0.002;"
print #1, "    "
print #1, "    vec3 pos = ro + t*rd;"
print #1, "    vec3 nor = calcNormalOpaque( pos, eps );"
print #1, ""
print #1, "    vec3 mateD = vec3(0.0);"
print #1, "    vec3 mateS = vec3(0.0);"
print #1, "    vec2 mateK = vec2(0.0);"
print #1, "    vec3 mateE = vec3(0.0);"
print #1, ""
print #1, "    float focc = 1.0;"
print #1, "    float fsha = 1.0;"
print #1, ""
print #1, "    if( m<1.5 ) // snail body"
print #1, "    {"
print #1, "        float dis = texture( iChannel1, 5.0*pos.xy ).x;"
print #1, ""
print #1, "        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );"
print #1, "        be = 1.0-smoothstep( -0.01, 0.01, be );        "
print #1, "        "
print #1, "        float ff = abs(matInfo.x-0.20);"
print #1, "        "
print #1, "        mateS = 6.0*mix( 0.7*vec3(2.0,1.2,0.2), vec3(2.5,1.8,0.9), ff );"
print #1, "        mateS += 2.0*dis;"
print #1, "        mateS *= 1.5;"
print #1, "        mateS *= 1.0 + 0.5*ff*ff;"
print #1, "        mateS *= 1.0-0.5*be;"
print #1, "        "
print #1, "        mateD = vec3(1.0,0.8,0.4);"
print #1, "        mateD *= dis;"
print #1, "        mateD *= 0.015;"
print #1, "        mateD += vec3(0.8,0.4,0.3)*0.15*be;"
print #1, "        "
print #1, "        mateK = vec2( 60.0, 0.7 + 2.0*dis );"
print #1, "        "
print #1, "        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );"
print #1, "        f = 1.0-pow( f, 8.0 );"
print #1, "        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);"
print #1, "        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);"
print #1, "        "
print #1, "        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));"
print #1, "        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );"
print #1, "    }"
print #1, "	else if( m<2.5 ) // shell"
print #1, "    {"
print #1, "        mateK = vec2(0.0);"
print #1, "        "
print #1, "        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );"
print #1, "        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );"
print #1, "        "
print #1, "        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );"
print #1, "        "
print #1, "        vec3 ral = texture( iChannel1, vec2(2.0*matInfo.w+matInfo.z*0.5,0.5) ).xxx;"
print #1, "        mateD *= 0.25 + 0.75*ral;"
print #1, "        "
print #1, "        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );"
print #1, "        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));"
print #1, "        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );"
print #1, "        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;"
print #1, "        "
print #1, "        mateK = vec2( 64.0, 0.2 );"
print #1, "        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;"
print #1, "    }"
print #1, "    else if( m<3.5 ) // plant"
print #1, "    {"
print #1, "        mateD = vec3(0.05,0.1,0.0)*0.2;"
print #1, "        mateS = vec3(0.1,0.2,0.02)*25.0;"
print #1, "        mateK = vec2(5.0,1.0);"
print #1, "        "
print #1, "        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );"
print #1, "        mateD += 0.2*fre*vec3(1.0,0.5,0.1);"
print #1, "        "
print #1, "        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;"
print #1, "        mateS *= 0.5 + 1.5*te;"
print #1, "        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);"
print #1, "    }"
print #1, "    else //if( m<4.5 ) // leave"
print #1, "    {"
print #1, "        vec3 p = pos - vec3(-1.8,0.6,-0.75);"
print #1, "        vec3 s = p;"
print #1, "        p = mat3(0.671212, 0.366685, -0.644218,"
print #1, "                -0.479426, 0.877583,  0.000000,"
print #1, "                 0.565354, 0.308854,  0.764842)*p;"
print #1, ""
print #1, "        vec3 q = p;"
print #1, "        p.y += 0.2*exp(-abs(2.0*p.z) );"
print #1, ""
print #1, "        float v = smoothstep( 0.01, 0.02, abs(p.z));"
print #1, "        "
print #1, "        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );"
print #1, ""
print #1, "        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;"
print #1, ""
print #1, "        float r = clamp((p.x+2.0)/4.0,0.0,1.0);"
print #1, "        r = r*(1.0-r)*(1.0-r)*6.0;"
print #1, "        float ff = length(p.xz/vec2(2.0,r));"
print #1, ""
print #1, "        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );"
print #1, "        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );"
print #1, "        mateD *= 1.0 + 0.25*te;"
print #1, "        mateD *= 0.8;"
print #1, "        "
print #1, "        mateS = vec3(0.15,0.2,0.02)*0.8;"
print #1, "        mateS *= 1.0 + 0.2*rr;"
print #1, "        mateS *= 0.8;"
print #1, ""
print #1, "        mateK = vec2(64.0,0.25);"
print #1, "        "
print #1, "        //---------------------"
print #1, "        "
print #1, "        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);"
print #1, "        nor = normalize( nor );"
print #1, ""
print #1, "        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );"
print #1, "        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );"
print #1, "        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );"
print #1, "        float dd = min(d1,min(d2,d4));"
print #1, "        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);"
print #1, "        "
print #1, "        d1 = abs( sdCircle( q.xz, vec2( 0.5, 0.20), 1.0*0.15 ));"
print #1, "        d2 = abs( sdCircle( q.xz, vec2( 0.8,-0.15), 0.5*0.15 ));"
print #1, "        d4 = abs( sdCircle( q.xz, vec2(-0.5,-0.20), 1.0*0.04 ));"
print #1, "        dd = min(d1,min(d2,d4));"
print #1, "        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);"
print #1, "        "
print #1, "        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );"
print #1, "        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );"
print #1, "        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;"
print #1, "        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    "
print #1, "    }"
print #1, "    "
print #1, "  "
print #1, "    vec3 hal = normalize( sunDir-rd );"
print #1, "    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );"
print #1, "    float occ = calcAO( pos, nor )*focc;"
print #1, "    float sss = calcSSS( pos, nor );"
print #1, "    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;"
print #1, "    "
print #1, "    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );"
print #1, "    float sha = calcSoftShadow( pos, sunDir, 20.0 ); "
print #1, "    dif1 *= sha*fsha;"
print #1, "    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );"
print #1, ""
print #1, "    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );"
print #1, ""
print #1, "    // illumination"
print #1, "    "
print #1, "    vec3 col = vec3(0.0);"
print #1, "    col += 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;           // sun"
print #1, "    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);    // sky"
print #1, "    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;                // bounce"
print #1, ""
print #1, "    col *= mateD;"
print #1, ""
print #1, "    col += 0.4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS; // sss"
print #1, "    col = pow(col,vec3(0.6,0.8,1.0));"
print #1, "    "
print #1, "    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;   // sun lobe1"
print #1, "    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y; // sun lobe2"
print #1, "	col += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0)); // sky"
print #1, ""
print #1, "    col += mateE;"
print #1, ""
print #1, "    return col;        "
print #1, "}"
print #1, ""
print #1, "vec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )"
print #1, "{"
print #1, "    vec3 oriCol = col;"
print #1, "    "
print #1, "    float dz = depth - t;"
print #1, "    float ao = clamp(dz*50.0,0.0,1.0);"
print #1, "    vec3  pos = ro + t*rd;"
print #1, "    vec3  nor = calcNormalTransparent( pos, 0.002 );"
print #1, "    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );"
print #1, "    vec3  hal = normalize( sunDir-rd );"
print #1, "    vec3  ref = reflect( -rd, nor );"
print #1, "    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );"
print #1, "    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );"
print #1, ""
print #1, ""
print #1, "    float ds = 1.6 - col.y;"
print #1, "    "
print #1, "    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );"
print #1, ""
print #1, "    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );"
print #1, "    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);"
print #1, "    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    "
print #1, "    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );"
print #1, "    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );"
print #1, "    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,texture( iChannel1, 0.8*nor.xy ).x)*(0.1+0.9*fre*fre);"
print #1, "    "
print #1, "    // hide aliasing a bit"
print #1, "    return mix( col, oriCol, smoothstep(0.6,1.0,fre) ); "
print #1, "}"
print #1, ""
print #1, "//--------------------------------------------"
print #1, ""
print #1, "vec3 calcNormal( in vec3 pos )"
print #1, "{"
print #1, "	vec3 eps = vec3( 0.0001, 0.0, 0.0 );"
print #1, "    float d = map(pos).x;"
print #1, "    return normalize( vec3("
print #1, "	    map(pos+eps.xyy).x - d,"
print #1, "	    map(pos+eps.yxy).x - d,"
print #1, "	    map(pos+eps.yyx).x - d)"
print #1, "	);"
print #1, "}"
print #1, ""
print #1, ""
print #1, "CP findIntersection(vec3 p, vec3 rd) {"
print #1, "     "
print #1, "    float tmin = 0.000;"
print #1, "    float tmax = 50.0;"
print #1, "    "
print #1, "	float precis = DIST_EPSILON;"
print #1, "    float t = tmin;"
print #1, "    float eta = -1.;"
print #1, "    vec3 res;"
print #1, "    for( int i=0; i<50; i++ )"
print #1, "    {"
print #1, "	  	res = map(p+rd*t);"
print #1, "        eta = res.z;"
print #1, "        if( res.x<precis || t>tmax ) break;"
print #1, "        t += res.x;"
print #1, "    }"
print #1, "    "
print #1, "    p+=rd*t;"
print #1, "    // calculate normal in the father point to avoid artifacts"
print #1, "    vec3 n = calcNormal(p-rd*(precis-res.x));"
print #1, "    CP cp = CP(t, n, res.y, p);"
print #1, ""
print #1, "    return cp;"
print #1, "}"
print #1, ""
print #1, "vec2 intersectOpaque( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )"
print #1, "{"
print #1, "    vec2 res = vec2(-1.0);"
print #1, "    "
print #1, "    float t = mindist;"
print #1, "    for( int i=ZERO; i<64; i++ )"
print #1, "    {"
print #1, "        vec3 p = ro + t*rd;"
print #1, "        vec2 h = mapOpaque( p, matInfo );"
print #1, "        res = vec2(t,h.y);"
print #1, ""
print #1, "        if( h.x<(0.001*t) ||  t>maxdist ) break;"
print #1, "        "
print #1, "        t += h.x*0.9;"
print #1, "    }"
print #1, "	return res;"
print #1, "}"
print #1, ""
print #1, "vec2 intersectTransparent( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )"
print #1, "{"
print #1, "    vec2 res = vec2(-1.0);"
print #1, "    "
print #1, "    float t = mindist;"
print #1, "    for( int i=ZERO; i<64; i++ )"
print #1, "    {"
print #1, "        vec3 p = ro + t*rd;"
print #1, "        vec2 h = mapTransparent( p, matInfo );"
print #1, "        res = vec2(t,h.y);"
print #1, ""
print #1, "        if( h.x<(0.001*t) ||  t>maxdist ) break;"
print #1, "        "
print #1, "        t += h.x;"
print #1, "    }"
print #1, "	return res;"
print #1, "}"
print #1, ""
print #1, "vec3 refractCaustic(vec3 p, vec3 rd, vec3 ld, float eta) {"
print #1, "     vec3 cl = vec3(1);"
print #1, "    for(int j = 0; j < 2; ++j) {"
print #1, ""
print #1, "        CP cp = findIntersection(p, rd);"
print #1, "        if (length(cp.p) > 2.) {"
print #1, "            break;"
print #1, "        }"
print #1, "        cl *= SURFACE_COLOR;//*(abs(dot(rd, cp.normal)));"
print #1, "        vec3 normal = sign(dot(rd, cp.normal))*cp.normal;"
print #1, "        rd = refract(rd, -normal, eta);"
print #1, ""
print #1, "        p = cp.p;"
print #1, "        eta = 1./eta;"
print #1, "        p += normal*DIST_EPSILON*2.;"
print #1, "    }"
print #1, "     float d = clamp( dot( rd, ld ), 0.0, 1.0 );"
print #1, "     return smoothstep(0.99, 1., d)*cl;"
print #1, "}"
print #1, ""
print #1, "vec3 caustic(vec3 p,vec3 ld, Ray ray) {"
print #1, "    vec3 VX = normalize(cross(ld, vec3(0,1,0)));"
print #1, "	vec3 VY = normalize(cross(ld, VX));     "
print #1, "    vec3 c = vec3(0);"
print #1, "    "
print #1, "    const int N =3;"
print #1, "    p += ray.cp.normal*DIST_EPSILON;"
print #1, "   "
print #1, "    for(int i = 0; i < N;++i) {"
print #1, "        "
print #1, "        float n1 = rand(p.xz*10. + vec2(iTime*2. +float(i)*123.));"
print #1, "        float n2 = rand(p.xz*15. +vec2(iTime*3. +float(i)*111.));"
print #1, ""
print #1, "        vec3 rd = ld+(VX*(n1-0.5)+VY*(n2-0.5))*0.1;"
print #1, "       // rd = ld;"
print #1, "        rd = normalize(rd);"
print #1, ""
print #1, " 		vec3 cl = refractCaustic(p, rd, ld, ray.eta);"
print #1, "        "
print #1, "      	c += cl* dot(rd,ray.cp.normal);"
print #1, "    }"
print #1, "    return c*3./float(N);"
print #1, "}"
print #1, ""
print #1, "vec3 getFloorColor(in Ray ray) {"
print #1, "    "
print #1, "    vec3 col = vec3(0);"
print #1, "    vec3 pos = ray.cp.p;"
print #1, "    vec3 ref = reflect( ray.rd, ray.cp.normal );"
print #1, "    "
print #1, "    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);"
print #1, "    col = 0.4 + 0.1*f*vec3(1.0);"
print #1, ""
print #1, "    float dif = clamp( dot( ray.cp.normal, LIGHT_DIR ), 0.0, 1.0 );"
print #1, "    vec3 brdf = vec3(0.0);"
print #1, "    brdf += caustic(pos, LIGHT_DIR, ray);"
print #1, "    brdf += 1.20*dif*vec3(1.00,0.90,0.60);"
print #1, "    col = col*brdf;"
print #1, "    // exclude branching"
print #1, "    col *= (ID_GLASS_WALL-ray.cp.mat);"
print #1, ""
print #1, "    return col;"
print #1, "}"
print #1, ""
print #1, "vec3 getColor(in Ray ray) {"
print #1, ""
print #1, "    vec3 p = ray.cp.p ;// can be used by SURFACE_COLOR define"
print #1, "    vec3 c1 = ray.col * SURFACE_COLOR;"
print #1, "    vec3 c2 = getFloorColor(ray);"
print #1, "    // exclude branching"
print #1, "    return mix(c2, c1, ray.cp.mat - ID_FLOOR);"
print #1, ""
print #1, "} "
print #1, ""
print #1, "vec3 getRayColor(Ray ray) {"
print #1, ""
print #1, ""
print #1, "    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));"
print #1, "    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));"
print #1, "    vec3 col = getColor(ray);"
print #1, ""
print #1, "    float q = exp(-d*ray.cp.dist);"
print #1, "    col = col*q+matColor*(1.-q);"
print #1, "    return col*ray.share;"
print #1, "}"
print #1, ""
print #1, "vec3 getColor(in Ray ray, vec3 pos) {"
print #1, "    vec3 col = vec3(0);"
print #1, "    if (ray.cp.mat == ID_FLOOR) {"
print #1, "        const float m = 3.;"
print #1, "        vec2 p = fract(vec2(-pos.x+0.5,pos.z+0.5)/m)*m;"
print #1, "        col = texture(iChannel0, p.xy).xyz;"
print #1, "    } else {"
print #1, "        col = ray.col * SURFACE_COLOR;"
print #1, "    }"
print #1, ""
print #1, " 	return col;"
print #1, ""
print #1, "}  "
print #1, ""
print #1, "#ifdef RECURSION"
print #1, ""
print #1, "void getRays(inout Ray ray, out Ray r1, out Ray r2) {"
print #1, "     vec3 p = ray.cp.p;"
print #1, "    float cs = dot(ray.cp.normal, ray.rd);"
print #1, "    // simple approximation"
print #1, "    float fresnel = 1.0-abs(cs);"
print #1, "    vec3 normal = sign(cs)*ray.cp.normal;"
print #1, "    vec3 refr = refract(ray.rd, -normal, ray.eta);"
print #1, "    vec3 refl = reflect(ray.rd, ray.cp.normal);"
print #1, "    vec3 z = normal*DIST_EPSILON*2.;"
print #1, "    p += z;"
print #1, "    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),1.-fresnel, 1./ray.eta);"
print #1, "    p -= 2.*z;"
print #1, "    r2 = Ray( refl, findIntersection(p, refl), vec3(0),fresnel, ray.eta);"
print #1, "}"
print #1, "    "
print #1, "// set of recursion functions"
print #1, "void rec2(inout Ray ray) {"
print #1, "	"
print #1, "    Ray r1,r2;"
print #1, "    getRays(ray, r1, r2);"
print #1, ""
print #1, "    ray.col += getRayColor(r1);"
print #1, "    ray.col += getRayColor(r2);"
print #1, "}"
print #1, ""
print #1, "void rec3(inout Ray ray) {"
print #1, "    Ray r1,r2;"
print #1, "    getRays(ray, r1, r2);"
print #1, "    "
print #1, "    rec2(r1);"
print #1, "    ray.col += getRayColor(r1);"
print #1, "    rec2(r2);"
print #1, "    ray.col += getRayColor(r2);"
print #1, "}"
print #1, ""
print #1, "void rec4(inout Ray ray) {"
print #1, "    Ray r1,r2;"
print #1, "    getRays(ray, r1, r2);"
print #1, "    "
print #1, "    rec3(r1);"
print #1, "    ray.col += getRayColor(r1);"
print #1, "    rec3(r2);"
print #1, "    ray.col += getRayColor(r2);"
print #1, "}"
print #1, ""
print #1, "void rec5(inout Ray ray) {"
print #1, "    Ray r1,r2;"
print #1, "    getRays(ray, r1, r2);"
print #1, "    "
print #1, "    rec4(r1);"
print #1, "    ray.col += getRayColor(r1);"
print #1, "    rec4(r2);"
print #1, "    ray.col += getRayColor(r2);"
print #1, "}"
print #1, ""
print #1, "void rec6(inout Ray ray) {"
print #1, "    Ray r1,r2;"
print #1, "    getRays(ray, r1, r2);"
print #1, "    "
print #1, "    rec5(r1);"
print #1, "    ray.col += getRayColor(r1);"
print #1, "    rec5(r2);"
print #1, "    ray.col += getRayColor(r2);"
print #1, "}"
print #1, ""
print #1, ""
print #1, ""
print #1, "vec3 castRay(vec3 p, vec3 rd) {"
print #1, "    CP cp = findIntersection(p, rd);"
print #1, "   "
print #1, "    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);"
print #1, "    calcRecursion(ray);"
print #1, "    ray.col += getRayColor(ray);"
print #1, "	return ray.col;"
print #1, "    "
print #1, "}"
print #1, ""
print #1, "#else"
print #1, ""
print #1, "Ray rays[RAY_COUNT];"
print #1, "vec3 castRay(vec3 p, vec3 rd) {"
print #1, "   "
print #1, "   "
print #1, "    CP cp = findIntersection(p, rd);"
print #1, "   "
print #1, "    rays[0] = Ray( rd, cp, vec3(0), 1., ETA);"
print #1, ""
print #1, "    for(int i = 0; i < RAY_COUNT/2; ++i) {"
print #1, "        Ray ray = rays[i];"
print #1, "        "
print #1, "		vec3 p = ray.cp.p;"
print #1, "       	 float cs = dot(ray.cp.normal, ray.rd);"
print #1, "        float fresnel = 1.0-abs(cs);"
print #1, "        //float fresnel =mix(0.2, 1., pow(1.-abs(cs),2.));"
print #1, "         vec3 normal = sign(cs)*ray.cp.normal;"
print #1, "    	vec3 refr = refract(ray.rd, -normal, ray.eta);"
print #1, "        vec3 refl = reflect(ray.rd, ray.cp.normal);"
print #1, "        vec3 z = normal*DIST_EPSILON*2.;"
print #1, "        p += z;"
print #1, "        rays[i*2+1] = Ray(refr, findIntersection(p, refr),  vec3(0),1.-fresnel, 1./ray.eta);"
print #1, "        p -= 2.*z;"
print #1, "        rays[i*2 + 2] = Ray( refl, findIntersection(p, refl), vec3(0),fresnel, ray.eta);"
print #1, "    }"
print #1, "    "
print #1, "    for(int i = RAY_COUNT-1; i>=0;--i) {"
print #1, "        Ray ray = rays[i];"
print #1, "        vec3 p =  ray.cp.p;"
print #1, "		vec3 atColor;"
print #1, "        float  d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));"
print #1, "        vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));"
print #1, "        vec3 col = getColor(ray, p);"
print #1, "        float q = exp(-d*ray.cp.dist);"
print #1, "        col = col*q+matColor*(1.-q);"
print #1, "        rays[(i-1)/2].col += col*ray.share;"
print #1, ""
print #1, "    }"
print #1, "   "
print #1, "	return rays[0].col;"
print #1, "}"
print #1, ""
print #1, "#endif"
print #1, ""
print #1, ""
print #1, "vec3 background( in vec3 d )"
print #1, "{"
print #1, "    // cheap cubemap"
print #1, "    vec3 n = abs(d);"
print #1, "    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: "
print #1, "              (n.y>n.x && n.y>n.z) ? d.zx/d.y:"
print #1, "                                     d.xy/d.z;"
print #1, "    "
print #1, "    // fancy blur"
print #1, "    vec3  col = vec3( 0.0 );"
print #1, "    for( int i=ZERO; i<200; i++ )"
print #1, "    {"
print #1, "        float h = float(i)/200.0;"
print #1, "        float an = 31.0*6.2831*h;"
print #1, "        vec2  of = vec2( cos(an), sin(an) ) * h;"
print #1, ""
print #1, "        vec3 tmp = texture( iChannel2, uv*0.25 + 0.0075*of, 4.0 ).yxz;"
print #1, "        col = smax( col, tmp, 0.5 );"
print #1, "    }"
print #1, "    "
print #1, "    return pow(col,vec3(3.5,3.0,6.0))*0.2;"
print #1, "}"
print #1, ""
print #1, "float horizonHeight(vec2 pos)"
print #1, "{"
print #1, "    horiz( vec2(-1, 0.1), vec2(-0.8, 0.3), pos );"
print #1, "    horiz( vec2(-0.8, 0.3), vec2(-0.6, 0.4), pos );"
print #1, "    horiz( vec2(-0.6, 0.4), vec2(-0.3, 0.2), pos );"
print #1, "    horiz( vec2(-0.3, 0.2), vec2(-0.1, 0.25), pos );"
print #1, "    horiz( vec2(-0.1, 0.25), vec2(-0., 0.2), pos );"
print #1, "    horiz( vec2(-0., 0.2), vec2(.1, 0.3), pos );"
print #1, "    horiz( vec2(.1, 0.3), vec2(.24, 0.32), pos );"
print #1, "    horiz( vec2(.24, 0.32), vec2(.3, 0.3), pos );"
print #1, "    horiz( vec2(.3, 0.3), vec2(.34, 0.32), pos );"
print #1, "    horiz( vec2(.34, 0.32), vec2(.36, 0.31), pos );"
print #1, "    horiz( vec2(.36, 0.31), vec2(.4, 0.27), pos );"
print #1, "    horiz( vec2(.4, 0.27), vec2(.47, 0.23), pos );"
print #1, "    horiz( vec2(.47, 0.23), vec2(.6, 0.15), pos );"
print #1, "    horiz( vec2(.6, 0.15), vec2(.8, 0.3), pos );"
print #1, "    horiz( vec2(.8, 0.3), vec2(1., 0.2), pos );"
print #1, "}"
print #1, ""
print #1, "vec3 sunColor(vec2 p)"
print #1, "{"
print #1, "    #define suncenter vec2(0, 0.1)"
print #1, "    #define sunradius 0.6"
print #1, "    #define sunfalloff 0.23"
print #1, "    #define suncolor vec3(0.8, 0.05, 0.05)"
print #1, "    "
print #1, "    #define skyradius 0.8"
print #1, "    #define skyfalloff 0.3"
print #1, "    #define skycolor vec3(0.05,0.,0.1)"
print #1, "    #define noise(x) (1. - texture(iChannel0, p*2.).r * 1. * (1.-sqrt(x)*0.92))"
print #1, "    "
print #1, "    float sunbrightness = smoothstep(sunradius+sunfalloff, sunradius-sunfalloff, length(p-suncenter));"
print #1, "    float skymask = smoothstep(skyradius+skyfalloff, skyradius-skyfalloff, length(p*vec2(0.5, 1.)-suncenter));"
print #1, "    "
print #1, "    return mix(skycolor*skymask*noise(skymask*0.5), suncolor, sunbrightness * noise(sunbrightness));"
print #1, "}"
print #1, ""
print #1, "vec3 bgColor(vec2 p)"
print #1, "{"
print #1, "    #define bgcolor vec3(0., 0.25, 0.7)"
print #1, "    #define noise2(x) (1. - texture(iChannel0, p*2.).r * 1. * (1.-sqrt(x)*0.72))"
print #1, "    "
print #1, "    p.y += p.x*p.x*0.1;"
print #1, "    "
print #1, "    float dist = sdTriangle(vec2(-1.5, 0.05), vec2(2.5, -0.7), vec2(-1.5, -1.), p);"
print #1, "    "
print #1, "    float mask = clamp(smoothstep(-0.2, 0.2, -dist) - smoothstep(-1., 1.5, p.x)*0.6, 0., 1.)*0.8;"
print #1, "    mask *= noise2(mask);"
print #1, "    "
print #1, "    return vec3(mask*bgcolor);"
print #1, "}"
print #1, ""
print #1, "vec3 prism(vec2 p)"
print #1, "{"
print #1, "    #define f1color vec3(0.5, 0.5, 0.24)"
print #1, "    #define f1color2 vec3(0.57, 0.27, 0.2)"
print #1, " 	float f1 = sdTriangle(vec2(-.195, -0.205), vec2(0.175, -0.24), vec2(-0.095, -0.38), p);"
print #1, "    vec3 f1col = smoothstep(0.01, -0.0, f1)*f1color*(p.x+0.26+p.y*0.5)*10.;"
print #1, "    f1col += smoothstep(0.01, -0.0, f1)*(f1color2);"
print #1, "    "
print #1, "    #define f2color vec3(0.4, 0.6, 0.7)"
print #1, "    float f2 = sdTriangle(vec2(-.2, -0.21), vec2(-0.1, -0.39), vec2(-0.2, -0.6), p);"
print #1, "    f2 = min(f2, sdTriangle(vec2(-.1, -0.77), vec2(-0.1, -0.39), vec2(-0.2, -0.6), p));"
print #1, "    vec3 f2col = clamp(smoothstep(0.01, -0.0, f2)* f2color * (.6-length(p-vec2(-0.15, -0.4)))*0.4, 0., 1.) * 2.6;"
print #1, "    "
print #1, "    #define f3color vec3(-0.5, -0.5, -0.5)"
print #1, "    float f3 = sdTriangle(vec2(0.18, -0.24), vec2(.18, -0.63), vec2(-0.095, -0.39), p);"
print #1, "    f3 = min(f3, sdTriangle(vec2(-.095, -0.77), vec2(.18, -0.63), vec2(-0.095, -0.39), p));"
print #1, "    vec3 f3col = clamp(smoothstep(0.01, -0.0, f3) * (.4-length(p-vec2(0.04, -0.5))), 0., 1.)*f3color;"
print #1, "    "
print #1, "    return (f2col+f1col+f3col)*noise(length(f2col+f1col+f3col));"
print #1, "}"
print #1, ""
print #1, "vec3 beam(vec2 p)"
print #1, "{"
print #1, "    #define whitebeamcolor vec3(0.5, 0.5, 1.)"
print #1, "    float wb = sdTriangle(vec2(-.14, -0.47), vec2(-.16, -0.45), vec2(-25., -10.), p);"
print #1, "    vec3 wbcol = whitebeamcolor * smoothstep(0.015, -0.015, wb)*2.;"
print #1, "    "
print #1, "    float rb = sdTriangle(vec2(.04, -0.47), vec2(30., -51.), vec2(25., -5.), p);"
print #1, "    #define leg1 (vec2(25., -5.) - vec2(.04, -0.47))"
print #1, "    #define ang1 atan(leg1.y, leg1.x)"
print #1, "    #define leg2 (vec2(30., -51.) - vec2(.04, -0.47))"
print #1, "    #define ang2 atan(leg2.y, leg2.x)"
print #1, "    #define rbleg(x) (x - vec2(.04, -0.47))"
print #1, "    #define rbangle(xv) ((atan(rbleg(xv).y, rbleg(xv).x) - ang1) / (ang2 - ang1))"
print #1, "    float rainbowangle = -rbangle(p)-0.1;"
print #1, "    vec3 rbcol = hsv2rgb_smooth(vec3(rainbowangle, 0.7 - length(rbleg(p))*0.2, 0.6 - length(rbleg(p))*0.2)) *  smoothstep(0.015, -0.015, rb);"
print #1, "    "
print #1, "    return (wbcol + rbcol)*noise(length(wbcol+rbcol));"
print #1, "}"
print #1, ""
print #1, "vec3 render(vec3 p, vec3 rd) {"
print #1, "    vec3 col= castRay(p, rd);"
print #1, "    return col;"
print #1, "}"
print #1, ""
print #1, "vec3 render( in vec3 ro, in vec3 rd, in vec2 q )"
print #1, "{"
print #1, "    //-----------------------------"
print #1, ""
print #1, "    vec3 col = background( rd );"
print #1, "    "
print #1, "    //-----------------------------"
print #1, "    "
print #1, "    float mindist = 1.0;"
print #1, "    float maxdist = 4.0;"
print #1, ""
print #1, "    vec4 matInfo;"
print #1, "    vec2 tm = intersectOpaque( ro, rd, mindist, maxdist, matInfo );"
print #1, "    if( tm.y>-0.5 && tm.x < maxdist )"
print #1, "    {"
print #1, "        col = shadeOpaque( ro, rd, tm.x, tm.y, matInfo );"
print #1, "        maxdist = tm.x;"
print #1, "    }"
print #1, ""
print #1, "    //-----------------------------"
print #1, "    "
print #1, "    tm = intersectTransparent( ro, rd, mindist, maxdist, matInfo );"
print #1, "    if( tm.y>-0.5 && tm.x < maxdist )"
print #1, "    {"
print #1, "        col = shadeTransparent( ro, rd, tm.x, tm.y, matInfo, col, maxdist );"
print #1, "    }"
print #1, ""
print #1, "    //-----------------------------"
print #1, "    "
print #1, "    float sun = clamp(dot(rd,sunDir),0.0,1.0);"
print #1, "    col += 1.0*vec3(1.5,0.8,0.7)*pow(sun,4.0);"
print #1, ""
print #1, "    //-----------------------------"
print #1, ""
print #1, "    col = pow( col, vec3(0.45) );"
print #1, "    "
print #1, "    col = vec3(1.05,1.0,1.0)*col*(0.7+0.3*col*max(3.0-2.0*col,0.0)) + vec3(0.0,0.0,0.04);"
print #1, ""
print #1, "    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);"
print #1, ""
print #1, "    return clamp( col, 0.0, 1.0 );"
print #1, "}"
print #1, ""
print #1, "mat3 setCamera( in vec3 ro, in vec3 ta, float cr )"
print #1, "{"
print #1, "	vec3 cw = normalize(ta-ro);"
print #1, "	vec3 cp = vec3(sin(cr), cos(cr),0.0);"
print #1, "	vec3 cu = normalize( cross(cw,cp) );"
print #1, "	vec3 cv =          ( cross(cu,cw) );"
print #1, "    return mat3( cu, cv, cw );"
print #1, "}"
print #1, ""
print #1, "mat3 setCamera( in vec3 ro, in vec3 rt )"
print #1, "{"
print #1, "    vec3 w = normalize(ro-rt);"
print #1, "    "
print #1, "    float m = sqrt(1.0-w.y*w.y);"
print #1, "    "
print #1, "    return mat3( w.z,     0.0, -w.x, "
print #1, "                 0.0,     m*m, -w.z*w.y,"
print #1, "                 w.x*m, w.y*m,  w.z*m );"
print #1, "}"
print #1, ""
print #1, "vec3 cycle(vec3 c, float s) "
print #1, "{"
print #1, "	float Cycles = max(1.175494351e-38F,3.402823466e+38F);"
print #1, "	return vec3(PI*0.125)+(PI*0.125)*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));"
print #1, "}"
print #1, ""
print #1, "vec3 getColor(int o)"
print #1, "{"
print #1, "	vec4 Z = vec4(0.3, 0.5, 0.6, 0.2);"
print #1, "	vec4 Y = vec4(0.1, 0.5, 1.0, -0.5);"
print #1, "	vec4 X = vec4(0.7, 0.8, 1.0, 0.3);"
print #1, "	vec3 orbitColor = cycle(X.xyz,ot.x)*X.w*ot.x + cycle(Y.xyz,ot.y)*Y.w*ot.y + cycle(Z.xyz,ot.z)*Z.w*ot.z;"
print #1, "	if (orbitColor.x >= 1.05125) orbitColor.x =0.;"
print #1, "	if (orbitColor.y >= 1.05125) orbitColor.y =0.;"
print #1, "	if (orbitColor.z >= 1.05125) orbitColor.z =0.;"
print #1, "	return clamp(3.0*orbitColor,0.0,1.05125);"
print #1, "}"
print #1, ""
print #1, "float scene(vec3 p)"
print #1, "{"
print #1, "	return min(100.-length(p) , abs(flame(p)) );"
print #1, "}"
print #1, ""
print #1, "vec4 raymarch(vec3 org, vec3 dir)"
print #1, "{"
print #1, "	float d = 0.0, glow = 0.0, eps = 0.02;"
print #1, "	vec3  p = org;"
print #1, "	bool glowed = false;"
print #1, "	"
print #1, "	for(int i=0; i<64; i++)"
print #1, "	{"
print #1, "		d = scene(p) + eps;"
print #1, "		p += d * dir;"
print #1, "		if( d>eps )"
print #1, "		{"
print #1, "			if(flame(p) < .0)"
print #1, "				glowed=true;"
print #1, "			if(glowed)"
print #1, "       			glow = float(i)/64.;"
print #1, "		}"
print #1, "	}"
print #1, "	return vec4(p,glow);"
print #1, "}"
print #1, ""
print #1, "float displacementSimple( vec2 p )"
print #1, "{"
print #1, "    float f;"
print #1, "    f  = 0.5000* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;"
print #1, "    f += 0.2500* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;"
print #1, "    f += 0.1250* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;"
print #1, "    f += 0.0625* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;"
print #1, "    "
print #1, "    return f;"
print #1, "}"
print #1, ""
print #1, ""
print #1, "vec3 getSceneColor(vec3 p, float material)"
print #1, "{"
print #1, "	if(material==1.0)"
print #1, "	{"
print #1, "		return vec3(1.0, 0.5, 0.5);"
print #1, "	}"
print #1, "	else if(material==2.0)"
print #1, "	{"
print #1, "		return vec3(0.5, 1.0, 0.5);"
print #1, "	}"
print #1, "	else if(material==3.0)"
print #1, "	{"
print #1, "		return vec3(0.5, 0.5, 1.0);"
print #1, "	}"
print #1, "	"
print #1, "	return vec3(0.0, 0.0, 0.0);"
print #1, "}"
print #1, ""
print #1, ""
print #1, "float getClosestDistance(vec3 p, out float material)"
print #1, "{"
print #1, "	float d = 0.0;"
print #1, "#if D_MAX_STEP_LENGTH_ENABLE"
print #1, "    float minD = 1.0; // restrict max step for better scattering evaluation"
print #1, "#else"
print #1, "	float minD = 10000000.0;"
print #1, "#endif"
print #1, "	material = 0.0;"
print #1, "    "
print #1, "    float yNoise = 0.0;"
print #1, "    float xNoise = 0.0;"
print #1, "    float zNoise = 0.0;"
print #1, "#if D_DETAILED_WALLS"
print #1, "    yNoise = 1.0*clamp(displacementSimple(p.xz*0.005),0.0,1.0);"
print #1, "    xNoise = 2.0*clamp(displacementSimple(p.zy*0.005),0.0,1.0);"
print #1, "    zNoise = 0.5*clamp(displacementSimple(p.xy*0.01),0.0,1.0);"
print #1, "#endif"
print #1, "    "
print #1, "	d = max(0.0, p.y - yNoise);"
print #1, "	if(d<minD)"
print #1, "	{"
print #1, "		minD = d;"
print #1, "		material = 2.0;"
print #1, "	}"
print #1, "	"
print #1, "	d = max(0.0,p.x - xNoise);"
print #1, "	if(d<minD)"
print #1, "	{"
print #1, "		minD = d;"
print #1, "		material = 1.0;"
print #1, "	}"
print #1, "	"
print #1, "	d = max(0.0,40.0-p.x - xNoise);"
print #1, "	if(d<minD)"
print #1, "	{"
print #1, "		minD = d;"
print #1, "		material = 1.0;"
print #1, "	}"
print #1, "	"
print #1, "	d = max(0.0,-p.z - zNoise);"
print #1, "	if(d<minD)"
print #1, "	{"
print #1, "		minD = d;"
print #1, "		material = 3.0;"
print #1, "    }"
print #1, "    "
print #1, "	return minD;"
print #1, "}"
print #1, ""
print #1, "vec3 evaluateLight(in vec3 pos)"
print #1, "{"
print #1, "    vec3 lightPos = LPOS;"
print #1, "    vec3 lightCol = LCOL;"
print #1, "    vec3 L = lightPos-pos;"
print #1, "    return lightCol * 1.0/dot(L,L);"
print #1, "}"
print #1, ""
print #1, "vec3 evaluateLight(in vec3 pos, in vec3 normal)"
print #1, "{"
print #1, "    vec3 lightPos = LPOS;"
print #1, "    vec3 L = lightPos-pos;"
print #1, "    float distanceToL = length(L);"
print #1, "    vec3 Lnorm = L/distanceToL;"
print #1, "    return max(0.0,dot(normal,Lnorm)) * evaluateLight(pos);"
print #1, "}"
print #1, ""
print #1, "// To simplify: wavelength independent scattering and extinction"
print #1, "void getParticipatingMedia(out float sigmaS, out float sigmaE, in vec3 pos)"
print #1, "{"
print #1, "    float heightFog = 7.0 + D_FOG_NOISE*3.0*clamp(displacementSimple(pos.xz*0.005 + iTime*0.01),0.0,1.0);"
print #1, "    heightFog = 0.3*clamp((heightFog-pos.y)*1.0, 0.0, 1.0);"
print #1, "    "
print #1, "    const float fogFactor = 1.0 + D_STRONG_FOG * 5.0;"
print #1, "    "
print #1, "    const float sphereRadius = 5.0;"
print #1, "    float sphereFog = clamp((sphereRadius-length(pos-vec3(20.0,19.0,-17.0)))/sphereRadius, 0.0,1.0);"
print #1, "    "
print #1, "    const float constantFog = 0.02;"
print #1, ""
print #1, "    sigmaS = constantFog + heightFog*fogFactor + sphereFog;"
print #1, "   "
print #1, "    const float sigmaA = 0.0;"
print #1, "    sigmaE = max(0.000000001, sigmaA + sigmaS); // to avoid division by zero extinction"
print #1, "}"
print #1, ""
print #1, "float phaseFunction()"
print #1, "{"
print #1, "    return 1.0/(4.0*3.14);"
print #1, "}"
print #1, ""
print #1, "float volumetricShadow(in vec3 from, in vec3 to)"
print #1, "{"
print #1, "#if D_VOLUME_SHADOW_ENABLE"
print #1, "    const float numStep = 16.0; // quality control. Bump to avoid shadow alisaing"
print #1, "    float shadow = 1.0;"
print #1, "    float sigmaS = 0.0;"
print #1, "    float sigmaE = 0.0;"
print #1, "    float dd = length(to-from) / numStep;"
print #1, "    for(float s=0.5; s<(numStep-0.1); s+=1.0)// start at 0.5 to sample at center of integral part"
print #1, "    {"
print #1, "        vec3 pos = from + (to-from)*(s/(numStep));"
print #1, "        getParticipatingMedia(sigmaS, sigmaE, pos);"
print #1, "        shadow *= exp(-sigmaE * dd);"
print #1, "    }"
print #1, "    return shadow;"
print #1, "#else"
print #1, "    return 1.0;"
print #1, "#endif"
print #1, "}"
print #1, ""
print #1, "void traceScene(bool improvedScattering, vec3 rO, vec3 rD, inout vec3 finalPos, inout vec3 normal, inout vec3 albedo, inout vec4 scatTrans)"
print #1, "{"
print #1, "	const int numIter = 100;"
print #1, "	"
print #1, "    float sigmaS = 0.0;"
print #1, "    float sigmaE = 0.0;"
print #1, "    "
print #1, "    vec3 lightPos = LPOS;"
print #1, "    "
print #1, "    // Initialise volumetric scattering integration (to view)"
print #1, "    float transmittance = 1.0;"
print #1, "    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);"
print #1, "    "
print #1, "	float d = 1.0; // hack: always have a first step of 1 unit to go further"
print #1, "	float material = 0.0;"
print #1, "	vec3 p = vec3(0.0, 0.0, 0.0);"
print #1, "    float dd = 0.0;"
print #1, "	for(int i=0; i<numIter;++i)"
print #1, "	{"
print #1, "		vec3 p = rO + d*rD;"
print #1, "        "
print #1, "        "
print #1, "    	getParticipatingMedia(sigmaS, sigmaE, p);"
print #1, "        "
print #1, "#ifdef D_DEMO_FREE"
print #1, "        if(D_USE_IMPROVE_INTEGRATION>0) // freedom/tweakable version"
print #1, "#else"
print #1, "        if(improvedScattering)"
print #1, "#endif"
print #1, "        {"
print #1, "            // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/"
print #1, "            vec3 S = evaluateLight(p) * sigmaS * phaseFunction()* volumetricShadow(p,lightPos);// incoming light"
print #1, "            vec3 Sint = (S - S * exp(-sigmaE * dd)) / sigmaE; // integrate along the current step segment"
print #1, "            scatteredLight += transmittance * Sint; // accumulate and also take into account the transmittance from previous steps"
print #1, ""
print #1, "            // Evaluate transmittance to view independentely"
print #1, "            transmittance *= exp(-sigmaE * dd);"
print #1, "        }"
print #1, "		else"
print #1, "        {"
print #1, "            // Basic scatering/transmittance integration"
print #1, "        #if D_UPDATE_TRANS_FIRST"
print #1, "            transmittance *= exp(-sigmaE * dd);"
print #1, "        #endif"
print #1, "            scatteredLight += sigmaS * evaluateLight(p) * phaseFunction() * volumetricShadow(p,lightPos) * transmittance * dd;"
print #1, "        #if !D_UPDATE_TRANS_FIRST"
print #1, "            transmittance *= exp(-sigmaE * dd);"
print #1, "        #endif"
print #1, "        }"
print #1, "        "
print #1, "		"
print #1, "        dd = getClosestDistance(p, material);"
print #1, "        if(dd<0.2)"
print #1, "            break; // give back a lot of performance without too much visual loss"
print #1, "		d += dd;"
print #1, "	}"
print #1, "	"
print #1, "	albedo = getSceneColor(p, material);"
print #1, "	"
print #1, "    finalPos = rO + d*rD;"
print #1, "    "
print #1, "    normal = calcNormal(finalPos);"
print #1, "    "
print #1, "    scatTrans = vec4(scatteredLight, transmittance);"
print #1, "}"
print #1, "void mainImage( out vec4 fragColor, in vec2 fragCoord )"
print #1, "{"
